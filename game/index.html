<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Fruit Merge Game</title>
    
    <!-- Load Tailwind CSS -->
    <link rel="stylesheet" href="css/tailwind.min.css">
    <!-- Load Matter.js Physics Engine -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>

    <!-- Load font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Chewy&display=swap" rel="stylesheet">
    
    <style>
        html, body {
            overflow: hidden;
            height: 100%;
            width: 100%;
            font-family: 'Inter', sans-serif;
            touch-action: none; 
            /* --- FIX: Bright background --- */
            background-color: #e0f2fe; /* bg-sky-100 */
        }
        
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 0;
        }

        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0;
            /* Use either max-width or max-height to constrain */
            width: min(100vw, 100vh * 2 / 3);
            /* Ensure the container fits within viewport height - use 100dvh for better mobile support */
            max-height: 100vh;
            max-height: 100dvh; /* Dynamic viewport height for mobile browsers */
            height: 100vh;
            height: 100dvh;
        }

        #game-wrapper {
            display: flex;
            flex-direction: column;
            /* --- FIX: Enforce 2:3 aspect ratio --- */
            aspect-ratio: 2 / 3;
            width: 100%;
            /* Flex shrink to fit within container */
            flex: 1 1 auto;
            min-height: 0;
            /* --- FIX: Bright wrapper background --- */
            background-color: #fff7ed; /* bg-orange-50 */
            overflow: hidden;
            position: relative;
            
            border-radius: 12px 12px 0 0;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        #game-header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            z-index: 20;
            pointer-events: auto;
        }
        
        #preview-fruit {
            position: absolute;
            left: 50%;
            z-index: 10;
            pointer-events: none;
            opacity: 0.8;
            border: 2px dashed rgba(0, 0, 0, 0.3); /* Darker dash for light bg */
            border-radius: 50%; /* Match circular fruit shape */
            
            display: flex;
            justify-content: center;
            align-items: center;
            text-shadow: 0 0 5px rgba(0,0,0,0.2);
            backface-visibility: hidden;
            /* Crisp image rendering for sharper preview */
            image-rendering: crisp-edges;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-optimize-contrast;
        }

        #game-canvas-wrapper {
            position: absolute;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 1;
            background-image: url('assets/weave_background.png');
            background-size: 200px 200px;
            background-position: center;
            background-repeat: repeat;
        }
        
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        #loading-screen {
            position: absolute;
            inset: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            /* --- FIX: Bright loading screen --- */
            background-color: #fff7ed; /* bg-orange-50 */
            z-index: 99;
            font-size: 1.5rem;
            color: #1f2937; /* text-gray-800 */
            font-weight: 500;
        }

        #pause-modal {
            transition: opacity 0.3s ease, transform 0.3s ease;
            pointer-events: auto;
        }
      
        #pause-modal h2 {
          font-family: "Chewy", system-ui;
          font-weight: 400;
          font-style: normal;
        }

        #pause-modal.hidden {
            opacity: 0;
            transform: scale(0.9);
            pointer-events: none;
        }

        #game-over-modal {
            pointer-events: auto;
        }

        #game-over-modal.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        #game-over-text {
            transition: opacity 0.5s ease;
            opacity: 0;
        }
        
        #game-over-text.visible {
            opacity: 1;
        }
        
        #game-over-content {
            transition: opacity 0.5s ease;
            opacity: 0;
        }
        
        #game-over-content.visible {
            opacity: 1;
        }

        #restart-confirm-modal {
            transition: opacity 0.3s ease, transform 0.3s ease;
            pointer-events: auto;
        }

        #restart-confirm-modal.hidden {
            opacity: 0;
            transform: scale(0.9);
            pointer-events: none;
        }

        #confetti-container {
            position: absolute;
            inset: 0;
            pointer-events: none;
            overflow: hidden;
            z-index: 15; 
        }
        .confetti-piece {
            position: absolute;
            background-color: white; 
            border-radius: 50%;
            opacity: 1;
            transition: transform 0.8s ease-out, opacity 0.8s ease-out;
        }
        
        #fruit-evolution-row {
            width: 100%;
            background: linear-gradient(to top, rgba(255, 255, 255, 0.95), rgba(255, 255, 255, 0.8));
            backdrop-filter: blur(8px);
            padding: 8px;
            /* Add safe area padding for iOS Safari at the bottom */
            padding-bottom: max(8px, env(safe-area-inset-bottom));
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: nowrap;
            gap: 4px;
            overflow-x: hidden;
            overflow-y: hidden;
            pointer-events: none;
            border-radius: 0 0 12px 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            flex-shrink: 0;
        }
        
        .evolution-fruit {
            flex-shrink: 1;
            min-width: 20px;
            width: 40px;
            height: 40px;
            max-width: 40px;
            border-radius: 50%;
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
            transition: filter 0.5s ease, opacity 0.5s ease;
            border: 2px solid rgba(0, 0, 0, 0.1);
            /* Crisp image rendering for sharper icons */
            image-rendering: crisp-edges;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-optimize-contrast;
        }
        
        .evolution-fruit.locked {
            filter: blur(4px) grayscale(0.5);
            opacity: 0.4;
        }
        
        .evolution-fruit.unlocked {
            filter: none;
            opacity: 1;
        }
        
        .evolution-fruit.current-game-locked {
            filter: blur(4px) grayscale(0.5);
            opacity: 0.4;
        }
    </style>
</head>
<!-- --- FIX: Bright body classes --- -->
<body class="bg-sky-100 text-gray-800">

    <div id="game-container">
        <div id="game-wrapper">
            
            <div id="loading-screen">Loading...</div>
          
            <!-- Pause/Start Modal -->
            <div id="pause-modal" class="absolute inset-0 bg-white/70 text-gray-900 backdrop-blur-md z-30 flex flex-col justify-center items-center text-center p-8">
                <img src="assets/10-watermelon.png" alt="Watermelon Logo" class="w-8 h-8 mb-4 object-contain" style="max-width: 64px; max-height: 64px; margin-bottom: 2rem;">
                <h2 id="pause-modal-title" class="text-5xl font-bold text-orange-500 mb-4" style="margin-bottom: 2rem;">Fruit Merge</h2>
                <p id="pause-modal-description" class="text-lg text-gray-700 max-w-md mb-8 leading-relaxed">
                    Drop and merge identical fruits to create bigger ones! Match two fruits of the same type to evolve them. Keep merging to score points and reach the watermelon. Don't let fruits stack above the red line!
                </p>
                <div class="flex flex-col gap-3 w-full max-w-xs">
                    <button id="resume-button" class="px-8 py-4 bg-green-500 text-white font-bold rounded-lg shadow-lg text-2xl hover:bg-green-400 transition-all">
                        Start
                    </button>
                    <button id="restart-menu-button" class="hidden px-6 py-3 bg-orange-500 text-white font-bold rounded-lg shadow-lg text-xl hover:bg-orange-400 transition-all">
                        Restart
                    </button>
                    <div class="flex gap-3">
                        <button id="music-toggle" class="flex-1 px-4 py-3 bg-blue-500 text-white font-bold rounded-lg shadow-lg text-lg hover:bg-blue-400 transition-all flex items-center justify-center gap-2">
                            <span>Music:</span>
                            <span id="music-status">On</span>
                        </button>
                        <button id="sounds-toggle" class="flex-1 px-4 py-3 bg-blue-500 text-white font-bold rounded-lg shadow-lg text-lg hover:bg-blue-400 transition-all flex items-center justify-center gap-2">
                            <span>Sounds:</span>
                            <span id="sounds-status">On</span>
                        </button>
                    </div>
                </div>
            </div>

            <!-- --- FIX: Bright header --- -->
            <div id="game-header" class="p-4 flex items-center bg-white/50 backdrop-blur-sm">
                <!-- Burger Menu Icon -->
                <button id="burger-menu-button" class="p-2 bg-transparent hover:bg-orange-100 rounded-lg transition-all group" title="Menu" aria-label="Menu">
                    <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-orange-600 group-hover:text-orange-700 transition-colors">
                        <line x1="3" y1="12" x2="21" y2="12"></line>
                        <line x1="3" y1="6" x2="21" y2="6"></line>
                        <line x1="3" y1="18" x2="21" y2="18"></line>
                    </svg>
                </button>
                
                <!-- Evenly spaced items: Score, High Score, Next Fruit -->
                <div class="flex-1 flex justify-evenly items-center">
                    <div class="text-center">
                        <span class="text-sm opacity-80">Score</span>
                        <div id="score" class="text-2xl font-bold">0</div>
                    </div>
                    <div class="text-center">
                        <span class="text-sm opacity-80">High Score</span>
                        <div id="high-score" class="text-2xl font-bold">0</div>
                    </div>
                    <div class="text-center">
                        <span class="text-sm opacity-80">Next</span>
                        <div id="next-fruit" class="flex justify-center items-center" style="height: 36px;">
                            <img id="next-fruit-img" src="" alt="Next fruit" style="max-height: 36px; max-width: 36px; object-fit: contain;">
                        </div>
                    </div>
                </div>
            </div>
            
            <div id="preview-fruit"></div>
            <div id="game-canvas-wrapper"></div>
            <div id="confetti-container"></div>

            <!-- --- FIX: Bright game over modal --- -->
            <div id="game-over-modal" class="hidden absolute inset-0 z-20 flex flex-col justify-center items-center text-center p-8">
                <h2 id="game-over-text" class="text-5xl font-bold text-red-500 mb-4">Game Over</h2>
                <div id="game-over-content" class="bg-white text-gray-900 rounded-lg p-8 flex flex-col items-center shadow-2xl">
                    <p class="text-xl mb-2">Final Score:</p>
                    <div id="final-score" class="text-4xl font-bold mb-8">0</div>
                    <!-- --- FIX: Playful button color --- -->
                    <button id="restart-button" class="px-6 py-3 bg-green-500 text-white font-bold rounded-lg shadow-lg text-xl hover:bg-green-400 transition-all">
                        Restart
                    </button>
                </div>
            </div>

            <!-- Restart Confirmation Modal -->
            <div id="restart-confirm-modal" class="hidden absolute inset-0 bg-white/70 text-gray-900 backdrop-blur-md z-40 flex flex-col justify-center items-center text-center p-8">
                <h2 class="text-3xl font-bold text-orange-600 mb-4">Restart Game?</h2>
                <p class="text-lg mb-8">Your current progress will be lost.</p>
                <div class="flex gap-4">
                    <button id="restart-confirm-yes" class="px-6 py-3 bg-red-500 text-white font-bold rounded-lg shadow-lg text-xl hover:bg-red-400 transition-all">
                        Yes, Restart
                    </button>
                    <button id="restart-confirm-no" class="px-6 py-3 bg-gray-500 text-white font-bold rounded-lg shadow-lg text-xl hover:bg-gray-400 transition-all">
                        Cancel
                    </button>
                </div>
            </div>
        </div>

        <div id="fruit-evolution-row"></div>
    </div>

    <script type="module">
        // Import Web Audio BGM controller
        import { createBgmController } from './audio/web-audio-bgm.js';

        // Wait for the *entire page* to load
        window.onload = () => {
            
            // --- DOM Elements ---
            const gameContainer = document.getElementById('game-container');
            const gameWrapper = document.getElementById('game-wrapper');
            const headerEl = document.getElementById('game-header');
            const canvasWrapper = document.getElementById('game-canvas-wrapper');
            const loadingScreen = document.getElementById('loading-screen');
            const previewFruitEl = document.getElementById('preview-fruit');
            const confettiContainer = document.getElementById('confetti-container');
            const pauseModal = document.getElementById('pause-modal');
            const resumeButton = document.getElementById('resume-button');
            const burgerMenuButton = document.getElementById('burger-menu-button');
            const restartMenuButton = document.getElementById('restart-menu-button');
            const musicToggle = document.getElementById('music-toggle');
            const musicStatus = document.getElementById('music-status');
            const soundsToggle = document.getElementById('sounds-toggle');
            const soundsStatus = document.getElementById('sounds-status');
            
            const scoreEl = document.getElementById('score');
            const highScoreEl = document.getElementById('high-score');
            const nextFruitEl = document.getElementById('next-fruit');
            const nextFruitImgEl = document.getElementById('next-fruit-img');
            const gameOverModal = document.getElementById('game-over-modal');
            const gameOverText = document.getElementById('game-over-text');
            const gameOverContent = document.getElementById('game-over-content');
            const finalScoreEl = document.getElementById('final-score');
            const restartButton = document.getElementById('restart-button');
            const restartConfirmModal = document.getElementById('restart-confirm-modal');
            const restartConfirmYes = document.getElementById('restart-confirm-yes');
            const restartConfirmNo = document.getElementById('restart-confirm-no');
            const fruitEvolutionRow = document.getElementById('fruit-evolution-row');

            // --- Matter.js modules ---
            const { Engine, Render, Runner, World, Bodies, Body, Events, Composite, Common } = Matter;

            // --- Pre-defined clip-paths for preview shapes (for CSS) ---
            const POLYGON_CLIP_PATHS = {
                'circle': 'circle(50%)',
                5: 'polygon(50% 0%, 100% 38%, 82% 100%, 18% 100%, 0% 38%)', // Pentagon
                6: 'polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%)', // Hexagon
                7: 'polygon(50% 0%, 90% 20%, 100% 60%, 75% 100%, 25% 100%, 0% 60%, 10% 20%)', // Heptagon
                8: 'polygon(50% 0%, 85% 15%, 100% 50%, 85% 85%, 50% 100%, 15% 85%, 0% 50%, 15% 15%)', // Octagon
                10: 'polygon(50% 0%, 80% 10%, 100% 35%, 100% 65%, 80% 90%, 50% 100%, 20% 90%, 0% 65%, 0% 35%, 20% 10%)' // Decagon
            };

            // --- Game Configuration ---
            
            const NATIVE_WIDTH = 400; // Our "design" width
            let scaleFactor = 1; // Will be set in initGame

            const FRUITS = [
                // Use 'baseRadius' for all pixel values - all fruits are now circles
                { level: 0, baseRadius: 22, color: '#2E3771', imagePath: 'assets/1-blueberry.png', score: 5, clipPath: POLYGON_CLIP_PATHS['circle'] },
                { level: 1, baseRadius: 26, color: '#842F28', imagePath: 'assets/2-strawberry.png', score: 10, clipPath: POLYGON_CLIP_PATHS['circle'] },
                { level: 2, baseRadius: 34, color: '#612B53', imagePath: 'assets/6-grapes.png', score: 20, clipPath: POLYGON_CLIP_PATHS['circle'] },
                { level: 3, baseRadius: 38, color: '#B06322', imagePath: 'assets/5-orange.png', score: 35, clipPath: POLYGON_CLIP_PATHS['circle'] },
                { level: 4, baseRadius: 48, color: '#952C29', imagePath: 'assets/4-apple.png', score: 55, clipPath: POLYGON_CLIP_PATHS['circle'] },
                { level: 5, baseRadius: 58, color: '#AE993B', imagePath: 'assets/3-lemon.png', score: 80, clipPath: POLYGON_CLIP_PATHS['circle'] },
                { level: 6, baseRadius: 66, color: '#8B8A62', imagePath: 'assets/7-cantaloupe.png', score: 110, clipPath: POLYGON_CLIP_PATHS['circle'] },
                { level: 7, baseRadius: 78, color: '#A27620', imagePath: 'assets/9-pineapple.png', score: 150, clipPath: POLYGON_CLIP_PATHS['circle'] },
                { level: 8, baseRadius: 90, color: '#67412B', imagePath: 'assets/8-coconut.png', score: 200, clipPath: POLYGON_CLIP_PATHS['circle'] },
                { level: 9, baseRadius: 102, color: '#5B723A', imagePath: 'assets/10-watermelon.png', score: 300, clipPath: POLYGON_CLIP_PATHS['circle'] },
            ];

            const MAX_FRUIT_LEVEL = FRUITS.length - 1;
            const STARTING_FRUIT_LEVELS = 4;
            const GAME_OVER_LINE_Y_PERCENT = 0.18; 
            const DROP_AREA_Y_PERCENT = 0.1; 
            const BASE_WALL_THICKNESS = 40; 
            const DROP_COOLDOWN_MS = 400; // Cooldown period between fruit drops
            const HIGHSCORE_KEY = 'fruit-merge-highscore';
            const GAME_STATE_KEY = 'fruit-merge-gamestate';
            const ACHIEVEMENTS_KEY = 'fruit-merge-achievements';
            
            // Preload fruit images
            const fruitImages = {};
            FRUITS.forEach(fruit => {
                const img = new Image();
                img.src = fruit.imagePath;
                fruitImages[fruit.level] = img;
            }); 

            // --- Game State ---
            let engine, render, runner, world;
            let score = 0;
            let highScore = 0; 
            let currentFruitLevel = 0;
            let nextFruitLevel = 0;
            let isGameOver = false;
            let isDropping = false; 
            let lastDropTime = 0; // Track the time of the last fruit drop
            let collisionTimeout = null;
            let currentPreviewX = 0; 
            let saveCounter = 0; 
            let achievedFruits = new Set(); // Track which fruit levels have been achieved 
            let currentGameMaxFruit = -1; // Track the maximum fruit level achieved in the current game session
            
            let bodiesToRemoveSet = new Set();
            let bodiesToAddArray = [];

            // --- Audio System ---
            // Sound effects are generated programmatically using the Web Audio API.
            // Background music is from Pixabay (see assets/README.md for details)
            // Using Web Audio API wrapper for reliable cross-browser volume control
            let audioContext = null;
            let bgmController = null;
            let isMusicEnabled = true; // User preference for music
            let areSoundsEnabled = true; // User preference for sound effects
            let isMusicPaused = false; // Current music playback state

            function initAudioContext() {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
            }
            
            function initBackgroundMusic() {
                if (!bgmController) {
                    try {
                        // Create Web Audio BGM controller with default gain of 0.25 (~-12dB)
                        bgmController = createBgmController({
                            audioElOrSrc: 'assets/children-music-loop-creative-fun-262427.mp3',
                            defaultGain: 0.25,  // Much louder than previous 0.05, but still pleasant
                            loop: true
                        });
                        
                        // Setup unlock on user gesture for iOS Safari
                        bgmController.unlockOnUserGesture();
                        
                        console.log('Background music controller initialized');
                    } catch (error) {
                        console.warn('Background music could not be initialized:', error);
                    }
                }
            }

            // Play a drop sound effect (short descending tone)
            function playDropSound() {
                if (!areSoundsEnabled) return; // Check if sounds are enabled
                initAudioContext();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.1);
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.1);
            }

            // Play a merge sound effect (cheerful ascending chime)
            function playMergeSound() {
                if (!areSoundsEnabled) return; // Check if sounds are enabled
                initAudioContext();
                const oscillator1 = audioContext.createOscillator();
                const oscillator2 = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator1.connect(gainNode);
                oscillator2.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator1.type = 'sine';
                oscillator2.type = 'sine';
                
                oscillator1.frequency.setValueAtTime(523.25, audioContext.currentTime); // C5
                oscillator1.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.05); // E5
                oscillator1.frequency.setValueAtTime(783.99, audioContext.currentTime + 0.1); // G5
                
                oscillator2.frequency.setValueAtTime(523.25 * 2, audioContext.currentTime); // C6
                oscillator2.frequency.setValueAtTime(659.25 * 2, audioContext.currentTime + 0.05); // E6
                oscillator2.frequency.setValueAtTime(783.99 * 2, audioContext.currentTime + 0.1); // G6
                
                gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                
                oscillator1.start(audioContext.currentTime);
                oscillator2.start(audioContext.currentTime);
                oscillator1.stop(audioContext.currentTime + 0.3);
                oscillator2.stop(audioContext.currentTime + 0.3);
            }

            // Play a game over sound effect (descending failure tone)
            function playGameOverSound() {
                if (!areSoundsEnabled) return; // Check if sounds are enabled
                initAudioContext();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(300, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(150, audioContext.currentTime + 0.5);
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.5);
            }

            // Start background music
            function startBackgroundMusic() {
                if (!isMusicEnabled) return; // Check if music is enabled
                initBackgroundMusic();
                if (bgmController && !isMusicPaused) {
                    bgmController.play().catch(error => {
                        console.warn('Autoplay was prevented. User interaction required.');
                    });
                }
            }

            // Stop background music with fade out
            function stopBackgroundMusic() {
                if (bgmController && bgmController.isPlaying()) {
                    isMusicPaused = true;
                    
                    // Fade out effect using Web Audio gain
                    const fadeOutInterval = setInterval(() => {
                        const currentGain = bgmController.getGainLinear();
                        if (currentGain > 0.01) {
                            bgmController.setGainLinear(currentGain - 0.01);
                        } else {
                            bgmController.pause();
                            bgmController.setGainLinear(0.25); // Reset gain for next play
                            clearInterval(fadeOutInterval);
                        }
                    }, 50);
                }
            }
            
            // Resume background music (for focus events)
            function resumeBackgroundMusic() {
                if (bgmController && isMusicPaused && !isGameOver) {
                    isMusicPaused = false;
                    bgmController.setGainLinear(0.25);
                    bgmController.play().catch(error => {
                        console.warn('Could not resume music:', error);
                    });
                }
            }

            // --- Game Dimensions (will be set in initGame) ---
            let headerHeight = 0;
            let boxWidth = 0;
            let boxHeight = 0;
            let gameOverLineY = 0;
            let dropAreaY = 0;
            let wallThickness = 40; 

            // --- Initialize Fruit Evolution Row ---
            function initFruitEvolutionRow() {
                fruitEvolutionRow.innerHTML = '';
                
                // Create evolution fruit icons
                FRUITS.forEach((fruit, index) => {
                    const fruitIcon = document.createElement('div');
                    fruitIcon.className = 'evolution-fruit';
                    fruitIcon.style.backgroundImage = `url('${fruit.imagePath}')`;
                    fruitIcon.setAttribute('data-level', index);
                    
                    // Check if fruit has been achieved in all-time
                    if (achievedFruits.has(index)) {
                        fruitIcon.classList.add('unlocked');
                    } else {
                        fruitIcon.classList.add('locked');
                    }
                    
                    // Additionally blur fruits larger than current game max
                    if (index > currentGameMaxFruit) {
                        fruitIcon.classList.add('current-game-locked');
                    }
                    
                    fruitEvolutionRow.appendChild(fruitIcon);
                });
                
                // Scale icons to fit in one row
                scaleEvolutionIcons();
            }
            
            // --- Update Evolution Row ---
            function updateEvolutionRow(fruitLevel) {
                // Mark this fruit level and all lower levels as achieved
                for (let i = 0; i <= fruitLevel; i++) {
                    achievedFruits.add(i);
                }
                
                // Update the current game maximum
                if (fruitLevel > currentGameMaxFruit) {
                    currentGameMaxFruit = fruitLevel;
                }
                
                // Save achievements to localStorage
                localStorage.setItem(ACHIEVEMENTS_KEY, JSON.stringify(Array.from(achievedFruits)));
                
                // Update the visual display
                const icons = fruitEvolutionRow.querySelectorAll('.evolution-fruit');
                icons.forEach((icon, index) => {
                    if (achievedFruits.has(index)) {
                        icon.classList.remove('locked');
                        icon.classList.add('unlocked');
                    }
                    
                    // Blur fruits larger than current game max
                    if (index > currentGameMaxFruit) {
                        icon.classList.add('current-game-locked');
                    } else {
                        icon.classList.remove('current-game-locked');
                    }
                });
            }
            
            // --- Scale Evolution Icons to fit in one row ---
            function scaleEvolutionIcons() {
                const rowWidth = fruitEvolutionRow.clientWidth;
                if (!rowWidth || rowWidth === 0) return; // Guard against zero width
                
                const numFruits = FRUITS.length;
                const gap = 4; // gap between icons in pixels
                const padding = 16; // 8px padding on each side
                
                // Calculate available width for icons
                const availableWidth = rowWidth - padding - (gap * (numFruits - 1));
                
                // Calculate maximum icon size that fits, with minimum of 20px
                const calculatedSize = Math.floor(availableWidth / numFruits);
                const maxIconSize = Math.max(20, Math.min(40, calculatedSize));
                
                // Apply the calculated size to all icons
                const icons = fruitEvolutionRow.querySelectorAll('.evolution-fruit');
                icons.forEach(icon => {
                    icon.style.width = `${maxIconSize}px`;
                    icon.style.height = `${maxIconSize}px`;
                    icon.style.maxWidth = `${maxIconSize}px`;
                });
            }
            
            // --- Load Achievements ---
            function loadAchievements() {
                const savedAchievements = localStorage.getItem(ACHIEVEMENTS_KEY);
                if (savedAchievements) {
                    try {
                        const achievementsArray = JSON.parse(savedAchievements);
                        achievedFruits = new Set(achievementsArray);
                    } catch (e) {
                        console.error("Could not parse saved achievements:", e);
                        achievedFruits = new Set();
                    }
                } else {
                    // By default, the first fruit (level 0) is always unlocked
                    achievedFruits = new Set([0]);
                }
            } 

            
            // --- ROBUST STARTUP ---
            const layoutCheckInterval = setInterval(() => {
                const w = gameWrapper.clientWidth;
                const h = gameWrapper.clientHeight;
                const hh = headerEl.clientHeight;
                
                if (w > 0 && h > 0 && hh > 0) {
                    clearInterval(layoutCheckInterval);
                    console.log(`Layout ready. Wrapper: ${w}x${h}, Header: ${hh}`);
                    loadingScreen.style.display = 'none';
                    initGame(); 
                    setupResizeObserver();
                    setupVisibilityHandlers();
                    setupPauseModal();
                } else {
                    console.log("Waiting for layout dimensions...");
                }
            }, 50);

            // --- Game Initialization ---
            function initGame() {
                // Load achievements first
                loadAchievements();
                
                headerHeight = headerEl.clientHeight;
                boxWidth = gameWrapper.clientWidth; 
                boxHeight = gameWrapper.clientHeight - headerHeight; 
                
                scaleFactor = boxWidth / NATIVE_WIDTH;
                wallThickness = BASE_WALL_THICKNESS * scaleFactor; 
                
                canvasWrapper.style.top = `${headerHeight}px`;
                canvasWrapper.style.height = `${boxHeight}px`;
                confettiContainer.style.top = `${headerHeight}px`;
                confettiContainer.style.height = `${boxHeight}px`;

                gameOverLineY = boxHeight * GAME_OVER_LINE_Y_PERCENT;
                dropAreaY = boxHeight * DROP_AREA_Y_PERCENT;
                currentPreviewX = boxWidth / 2;

                isGameOver = false;
                isDropping = false;
                lastDropTime = 0; // Reset drop time on new game
                saveCounter = 0;
                currentGameMaxFruit = -1; // Reset current game max on new game
                
                highScore = parseInt(localStorage.getItem(HIGHSCORE_KEY) || '0');
                highScoreEl.textContent = highScore;
                
                gameOverModal.classList.add('hidden');
                gameOverText.classList.remove('visible');
                gameOverContent.classList.remove('visible');
                
                bodiesToRemoveSet.clear();
                bodiesToAddArray = [];

                engine = Engine.create();
                world = engine.world;
                world.gravity.y = 0.8; 

                render = Render.create({
                    element: canvasWrapper, 
                    engine: engine,
                    options: {
                        width: boxWidth,
                        height: boxHeight,
                        wireframes: false,
                        /* Transparent background to show weave_background.png */
                        background: 'transparent'
                    }
                });

                runner = Runner.create();
                World.clear(world, false);

                const wallOptions = {
                    isStatic: true,
                    restitution: 0.1,
                    friction: 0.2,
                    /* --- FIX: Playful wall color --- */
                    render: { fillStyle: '#b45309' } // bg-amber-700
                };

                World.add(world, [
                    Bodies.rectangle(boxWidth / 2, boxHeight - wallThickness / 2, boxWidth, wallThickness, { ...wallOptions, label: 'ground' }),
                    Bodies.rectangle(wallThickness / 2, boxHeight / 2, wallThickness, boxHeight, { ...wallOptions, label: 'wall-left' }),
                    Bodies.rectangle(boxWidth - wallThickness / 2, boxHeight / 2, wallThickness, boxHeight, { ...wallOptions, label: 'wall-right' })
                ]);

                const gameOverLine = Bodies.rectangle(
                    boxWidth / 2,
                    gameOverLineY,
                    boxWidth,
                    2,
                    {
                        isStatic: true,
                        isSensor: true,
                        label: 'gameOverLine',
                        render: { fillStyle: '#FF0000', opacity: 0.5 } 
                    }
                );
                World.add(world, gameOverLine);

                const savedStateString = localStorage.getItem(GAME_STATE_KEY);
                let loadedState = null;
                if (savedStateString) {
                    try {
                        loadedState = JSON.parse(savedStateString);
                    } catch (e) {
                        console.error("Could not parse saved state:", e);
                        localStorage.removeItem(GAME_STATE_KEY); 
                    }
                }

                if (loadedState) {
                    console.log("Loading from saved state...");
                    const loadedScaleFactor = loadedState.boxWidth ? (boxWidth / loadedState.boxWidth) : 1;

                    loadedState.fruits.forEach(fruit => {
                        const body = createFruitBody(
                            fruit.x * loadedScaleFactor, 
                            fruit.y * loadedScaleFactor, 
                            fruit.level
                        );
                        
                        Body.setAngle(body, fruit.angle);
                        Body.setVelocity(body, { x: fruit.velocityX * loadedScaleFactor, y: fruit.velocityY * loadedScaleFactor });
                        Body.setAngularVelocity(body, fruit.angularVelocity);
                        World.add(world, body);
                        
                        // Mark this fruit level as achieved and update current game max
                        updateEvolutionRow(fruit.level);
                    });
                    score = loadedState.score;

                    // Restore both current and next fruit levels from saved state
                    if (loadedState.currentFruitLevel !== undefined) {
                        // Set nextFruitLevel first since spawnCurrentFruit() uses it
                        nextFruitLevel = loadedState.currentFruitLevel;
                        spawnCurrentFruit(); // This will set currentFruitLevel = nextFruitLevel
                        nextFruitLevel = loadedState.nextFruitLevel; // Then restore the actual next fruit
                        // Update the next fruit display with the restored value
                        const nextFruitData = FRUITS[nextFruitLevel];
                        nextFruitImgEl.src = nextFruitData.imagePath;
                        nextFruitImgEl.style.display = 'block';
                    } else {
                        // Fallback for old save data without currentFruitLevel
                        nextFruitLevel = loadedState.nextFruitLevel;
                        spawnCurrentFruit(); 
                        spawnNextFruit(); 
                    }
                    
                    // Also mark the next fruit as achieved and update current game max
                    updateEvolutionRow(nextFruitLevel); 
                } else {
                    console.log("Starting new game...");
                    score = 0;
                    spawnNextFruit(); 
                    spawnCurrentFruit(); 
                    spawnNextFruit(); 
                }
                updateScore(score); 


                Render.run(render);
                Runner.run(runner, engine);
                
                // Initialize fruit evolution row
                initFruitEvolutionRow();

                Events.on(render, 'afterRender', () => {
                    const context = render.context;
                    const bodies = Composite.allBodies(world);

                    context.save(); 
                    
                    bodies.forEach(body => {
                        if (body.label !== 'fruit') return;

                        const fruitData = FRUITS[body.fruitLevel];
                        if (fruitData) {
                            const scaledRadius = fruitData.baseRadius * scaleFactor;
                            const img = fruitImages[body.fruitLevel];
                            
                            if (img && img.complete) {
                                // Calculate dimensions preserving aspect ratio
                                const containerSize = scaledRadius * 2;
                                const imgAspect = img.width / img.height;
                                
                                let drawWidth, drawHeight;
                                if (imgAspect > 1) {
                                    // Wider than tall
                                    drawWidth = containerSize;
                                    drawHeight = containerSize / imgAspect;
                                } else {
                                    // Taller than wide or square
                                    drawHeight = containerSize;
                                    drawWidth = containerSize * imgAspect;
                                }
                                
                                const offsetX = drawWidth / 2;
                                const offsetY = drawHeight / 2;
                                
                                context.save();
                                context.translate(body.position.x, body.position.y);
                                context.rotate(body.angle);
                                // Disable image smoothing for crisp, sharp rendering
                                context.imageSmoothingEnabled = false;
                                context.drawImage(img, -offsetX, -offsetY, drawWidth, drawHeight);
                                context.restore();
                            }
                        }
                    });

                    context.restore(); 
                });
                
                addEventListeners();
            }

            // --- Fruit Creation ---
            
            function createFruitBody(x, y, level, options = {}) {
                const fruitData = FRUITS[level];
                if (!fruitData) return null;

                const bodyOptions = {
                    label: 'fruit',
                    fruitLevel: level,
                    friction: 0.3,
                    restitution: 0.2,
                    density: 0.001,
                    render: {
                        // Make circle slightly visible with semi-transparent fill
                        fillStyle: 'rgba(0, 0, 0, 0.2)',
                        strokeStyle: 'transparent',
                        lineWidth: 0
                    },
                    ...options
                };
                
                const scaledRadius = fruitData.baseRadius * scaleFactor;
                return Bodies.circle(x, y, scaledRadius, bodyOptions);
            }

            function spawnCurrentFruit() {
                currentFruitLevel = nextFruitLevel;
                const fruitData = FRUITS[currentFruitLevel];
                const scaledRadius = fruitData.baseRadius * scaleFactor;
                
                previewFruitEl.style.width = `${scaledRadius * 2}px`;
                previewFruitEl.style.height = `${scaledRadius * 2}px`;
                // Make preview background transparent
                previewFruitEl.style.backgroundColor = 'transparent';
                
                // Use image for preview
                previewFruitEl.style.backgroundImage = `url('${fruitData.imagePath}')`;
                // Use 'contain' to preserve aspect ratio
                previewFruitEl.style.backgroundSize = 'contain';
                previewFruitEl.style.backgroundPosition = 'center';
                previewFruitEl.style.backgroundRepeat = 'no-repeat';
                previewFruitEl.textContent = '';
                
                previewFruitEl.style.top = `${headerHeight + dropAreaY - scaledRadius}px`;
                
                const clipPath = fruitData.clipPath || POLYGON_CLIP_PATHS['circle'];
                previewFruitEl.style.clipPath = clipPath;
                previewFruitEl.style.borderRadius = clipPath === POLYGON_CLIP_PATHS['circle'] ? '50%' : '0';

                moveFruit(currentPreviewX, true); 
            }

            function spawnNextFruit() {
                nextFruitLevel = Math.floor(Math.random() * STARTING_FRUIT_LEVELS);
                const fruitData = FRUITS[nextFruitLevel];
                
                // Update next fruit image
                nextFruitImgEl.src = fruitData.imagePath;
                nextFruitImgEl.style.display = 'block';
            }
            
            // --- Game Controls (for the DIV) ---

            function moveFruit(clientX, isInternalCall = false) {
                if (isGameOver) return;

                const fruitData = FRUITS[currentFruitLevel];
                const scaledRadius = fruitData.baseRadius * scaleFactor;
                let x;

                if (isInternalCall) {
                    x = clientX; 
                } else {
                    const rect = gameWrapper.getBoundingClientRect();
                    x = clientX - rect.left; 
                }
                
                const constrainedX = Math.max(
                    scaledRadius + wallThickness, // Use scaled values
                    Math.min(boxWidth - scaledRadius - wallThickness, x) // Use scaled values
                );
                
                currentPreviewX = constrainedX;
                previewFruitEl.style.transform = `translateX(${constrainedX - boxWidth / 2}px) translateX(-50%)`;
            }

            function dropFruit() {
                if (isGameOver || isDropping) return;

                // Check cooldown period to limit drop frequency
                const currentTime = Date.now();
                if (currentTime - lastDropTime < DROP_COOLDOWN_MS) {
                    return; // Still in cooldown period
                }

                // Check if any fruits are already resting above the game over line
                const gameOverLine = world.bodies.find(b => b.label === 'gameOverLine');
                if (gameOverLine) {
                    const fruitsAboveLine = Composite.allBodies(world).filter(body => {
                        if (body.label !== 'fruit') return false;
                        // Check if fruit is above the line and nearly stationary
                        const isAboveLine = body.position.y < gameOverLineY;
                        const isStationary = Math.abs(body.velocity.y) < 0.5 && Math.abs(body.velocity.x) < 0.5;
                        return isAboveLine && isStationary;
                    });
                    
                    if (fruitsAboveLine.length > 0) {
                        triggerGameOver();
                        return;
                    }
                }

                isDropping = true;
                lastDropTime = currentTime; // Record the drop time
                
                const droppedFruit = createFruitBody(
                    currentPreviewX, 
                    dropAreaY,
                    currentFruitLevel
                );
                
                if (!droppedFruit) {
                    isDropping = false;
                    return;
                }
                
                // Update evolution row when a fruit is dropped
                updateEvolutionRow(currentFruitLevel);
                
                World.add(world, droppedFruit);
                
                // Play drop sound effect
                playDropSound();
                
                previewFruitEl.style.opacity = '0';

                if (collisionTimeout) clearTimeout(collisionTimeout);
                collisionTimeout = setTimeout(() => {
                    if (!isGameOver && droppedFruit && world.bodies.includes(droppedFruit)) {
                        if (Matter.Collision.collides(droppedFruit, world.bodies.find(b => b.label === 'gameOverLine'))) {
                            triggerGameOver();
                        }
                    }
                    collisionTimeout = null;
                }, 1500);

                setTimeout(() => {
                    if (!isGameOver) {
                        spawnCurrentFruit(); 
                        spawnNextFruit(); 
                        previewFruitEl.style.opacity = '0.8';
                        isDropping = false;
                    }
                }, DROP_COOLDOWN_MS); // Show preview fruit only after cooldown completes
            }

            // --- Confetti Effect ---
            function createConfetti(x, y, color1, color2) {
                const numPieces = 25;
                for (let i = 0; i < numPieces; i++) {
                    const piece = document.createElement('div');
                    piece.classList.add('confetti-piece');
                    
                    const randomColor = Math.random() < 0.5 ? color1 : color2;
                    piece.style.backgroundColor = randomColor;
                    
                    const pieceSize = 10 * scaleFactor;
                    piece.style.width = `${pieceSize}px`;
                    piece.style.height = `${pieceSize}px`;

                    piece.style.left = `${x}px`;
                    piece.style.top = `${y}px`;
                    
                    confettiContainer.appendChild(piece);

                    const angle = Math.random() * Math.PI * 2; 
                    const distance = (Math.random() * 70 + 40) * scaleFactor; 
                    const finalX = x + Math.cos(angle) * distance;
                    const finalY = y + Math.sin(angle) * distance;

                    setTimeout(() => {
                        piece.style.transform = `translate(${finalX - x}px, ${finalY - y}px) scale(0)`;
                        piece.style.opacity = '0';
                    }, 10); 

                    setTimeout(() => {
                        piece.remove();
                    }, 800);
                }
            }
            
            // --- Save Game State ---
            function saveGameState() {
                if (isGameOver || !world) return;

                const fruits = Composite.allBodies(world)
                    .filter(body => body.label === 'fruit')
                    .map(body => ({
                        x: body.position.x,
                        y: body.position.y,
                        level: body.fruitLevel,
                        angle: body.angle,
                        velocityX: body.velocity.x,
                        velocityY: body.velocity.y,
                        angularVelocity: body.angularVelocity
                    }));
                
                const gameState = {
                    fruits: fruits,
                    score: score,
                    currentFruitLevel: currentFruitLevel,
                    nextFruitLevel: nextFruitLevel,
                    boxWidth: boxWidth // Save boxWidth for scaling on load
                };

                localStorage.setItem(GAME_STATE_KEY, JSON.stringify(gameState));
            }


            // --- Event Listeners ---
            function addEventListeners() {
                Events.off(engine, 'collisionStart');
                Events.off(engine, 'collisionStay');
                Events.off(engine, 'afterUpdate');
                
                // 1. DETECT collisions
                Events.on(engine, 'collisionStart', (event) => {
                    if (isGameOver) return;
                    const pairs = event.pairs;
                    for (let i = 0; i < pairs.length; i++) {
                        const pair = pairs[i];
                        const bodyA = pair.bodyA;
                        const bodyB = pair.bodyB;

                        if (bodyA.label !== 'fruit' || bodyB.label !== 'fruit') continue;
                        
                        if (bodiesToRemoveSet.has(bodyA.id) || bodiesToRemoveSet.has(bodyB.id)) {
                            continue;
                        }

                        if (bodyA.fruitLevel === bodyB.fruitLevel) {
                            const level = bodyA.fruitLevel;
                            if (level === MAX_FRUIT_LEVEL) continue; 
                            
                            // Prevent merging if both fruits are above the game over line
                            const bodyAAboveLine = bodyA.position.y < gameOverLineY;
                            const bodyBAboveLine = bodyB.position.y < gameOverLineY;
                            if (bodyAAboveLine && bodyBAboveLine) {
                                continue; // Skip this merge
                            }
                            
                            const newX = (bodyA.position.x + bodyB.position.x) / 2;
                            const newY = (bodyA.position.y + bodyB.position.y) / 2;
                            const nextLevel = level + 1;
                            
                            bodiesToAddArray.push({
                                x: newX,
                                y: newY,
                                level: nextLevel,
                                score: FRUITS[level].score,
                                color1: FRUITS[level].color, 
                                color2: FRUITS[nextLevel].color
                            });
                            bodiesToRemoveSet.add(bodyA.id);
                            bodiesToRemoveSet.add(bodyB.id);
                        }
                    }
                });
                
                // 2. ACT on collisions
                Events.on(engine, 'afterUpdate', () => {
                    if (bodiesToRemoveSet.size > 0) {
                        const bodiesToRemove = Composite.allBodies(world).filter(body => bodiesToRemoveSet.has(body.id));
                        bodiesToRemove.forEach(body => {
                            World.remove(world, body);
                        });
                        
                        let didMerge = false; 
                        bodiesToAddArray.forEach(data => {
                            const newFruit = createFruitBody(data.x, data.y, data.level, {
                                velocity: { x: Common.random(-1, 1), y: -2 } 
                            });
                            World.add(world, newFruit);
                            updateScore(score + data.score); 
                            createConfetti(data.x, data.y, data.color1, data.color2); 
                            
                            // Update evolution row when new fruit level is achieved
                            updateEvolutionRow(data.level);
                            
                            didMerge = true;
                        });
                        
                        if (didMerge) {
                            // Play merge sound effect
                            playMergeSound();
                            if (navigator.vibrate) {
                                navigator.vibrate(50); 
                            }
                        }

                        bodiesToRemoveSet.clear();
                        bodiesToAddArray = [];
                    }

                    if (!isGameOver) {
                        saveCounter++;
                        if (saveCounter >= 60) { // Save roughly every second
                            saveGameState();
                            saveCounter = 0;
                        }
                    }
                });

                // --- Game Over Check ---
                Events.on(engine, 'collisionStay', (event) => {
                    if (isGameOver || collisionTimeout) return; 
                    const pairs = event.pairs;
                    for (let i = 0; i < pairs.length; i++) {
                        const pair = pairs[i];
                        const bodyA = pair.bodyA;
                        const bodyB = pair.bodyB;
                        let fruitBody = null;

                        if (bodyA.label === 'gameOverLine' && bodyB.label === 'fruit') fruitBody = bodyB;
                        if (bodyB.label === 'gameOverLine' && bodyA.label === 'fruit') fruitBody = bodyA;

                        if (fruitBody) {
                            // Check if the CENTER of the fruit is above the line (not just touching it)
                            const isCenterAboveLine = fruitBody.position.y < gameOverLineY;
                            // Only trigger game over if center is above line AND fruit is stationary
                            if (isCenterAboveLine && fruitBody.velocity.y < 0.05 && fruitBody.velocity.y > -0.05 && Math.abs(fruitBody.velocity.x) < 0.1) {
                                triggerGameOver();
                                break;
                            }
                        }
                    }
                });
                
                // --- UI Event Listeners ---
                gameWrapper.addEventListener('pointerdown', handlePointerDown, { passive: false });
                gameWrapper.addEventListener('pointermove', handlePointerMove, { passive: false });
                gameWrapper.addEventListener('pointerup', handlePointerUp, { passive: false });
                
                // Prevent toolbar events from bubbling to game
                headerEl.addEventListener('pointerdown', stopToolbarEventBubbling, { passive: false });
                headerEl.addEventListener('pointermove', stopToolbarEventBubbling, { passive: false });
                headerEl.addEventListener('pointerup', stopToolbarEventBubbling, { passive: false });
                
                restartButton.addEventListener('click', handleRestart);
                restartMenuButton.addEventListener('click', handleRestartFromMenu);
                restartConfirmYes.addEventListener('click', confirmRestart);
                restartConfirmNo.addEventListener('click', cancelRestart);
                burgerMenuButton.addEventListener('click', togglePauseMenu);
                resumeButton.addEventListener('click', togglePauseMenu);
                musicToggle.addEventListener('click', toggleMusic);
                soundsToggle.addEventListener('click', toggleSounds);
            }
            
            // --- Helper to check if any modal is visible ---
            function isModalVisible() {
                return !pauseModal.classList.contains('hidden') || 
                       !gameOverModal.classList.contains('hidden') || 
                       !restartConfirmModal.classList.contains('hidden');
            }
            
            // --- Event Handlers (to allow removal) ---
            function handlePointerDown(e) { 
                if (isModalVisible()) return;
                e.preventDefault(); 
                moveFruit(e.clientX); 
            }
            function handlePointerMove(e) { 
                if (isModalVisible()) return;
                e.preventDefault(); 
                moveFruit(e.clientX); 
            }
            function handlePointerUp(e) { 
                if (isModalVisible()) return;
                e.preventDefault(); 
                dropFruit(); 
            }
            
            // --- Prevent toolbar pointer events from bubbling ---
            function stopToolbarEventBubbling(e) {
                e.stopPropagation();
            }
            
            // --- Toggle Pause Menu ---
            function togglePauseMenu() {
                const isHidden = pauseModal.classList.contains('hidden');
                
                if (isHidden) {
                    // Show pause menu
                    pauseModal.classList.remove('hidden');
                    // Update button text
                    if (localStorage.getItem(GAME_STATE_KEY) && !isGameOver) {
                        resumeButton.textContent = 'Resume';
                        restartMenuButton.classList.remove('hidden');
                    } else {
                        resumeButton.textContent = 'Start';
                        restartMenuButton.classList.add('hidden');
                    }
                    // Pause music if playing
                    if (bgmController && bgmController.isPlaying()) {
                        bgmController.pause();
                    }
                } else {
                    // Hide pause menu
                    pauseModal.classList.add('hidden');
                    
                    // Initialize background music on first interaction if not already done
                    if (!bgmController) {
                        initBackgroundMusic();
                    }
                    
                    // Resume/start music if enabled and not game over
                    if (isMusicEnabled && !isGameOver) {
                        isMusicPaused = false;
                        startBackgroundMusic();
                    }
                }
            }
            
            // --- Toggle Music ---
            function toggleMusic() {
                isMusicEnabled = !isMusicEnabled;
                musicStatus.textContent = isMusicEnabled ? 'On' : 'Off';
                
                if (isMusicEnabled) {
                    // Enable music - start playing if not in pause menu and not game over
                    if (pauseModal.classList.contains('hidden') && !isGameOver) {
                        startBackgroundMusic();
                    }
                } else {
                    // Disable music - stop if playing
                    if (bgmController && bgmController.isPlaying()) {
                        bgmController.pause();
                    }
                }
            }
            
            // --- Toggle Sounds ---
            function toggleSounds() {
                areSoundsEnabled = !areSoundsEnabled;
                soundsStatus.textContent = areSoundsEnabled ? 'On' : 'Off';
            }
            
            // --- Restart from Pause Menu ---
            function handleRestartFromMenu() {
                // Close pause menu first
                pauseModal.classList.add('hidden');
                // Show confirmation modal
                restartConfirmModal.classList.remove('hidden');
            }
            
            function showRestartConfirmation() {
                if (!isGameOver) {
                    restartConfirmModal.classList.remove('hidden');
                }
            }
            
            function confirmRestart() {
                restartConfirmModal.classList.add('hidden');
                handleRestart();
            }
            
            function cancelRestart() {
                restartConfirmModal.classList.add('hidden');
            }
            
            function handleRestart() {
                localStorage.removeItem(GAME_STATE_KEY);
                
                // Reset game over modal visibility states
                gameOverModal.classList.add('hidden');
                gameOverText.classList.remove('visible');
                gameOverContent.classList.remove('visible');
                
                // Stop background music before restart
                stopBackgroundMusic();
                
                Runner.stop(runner);
                Render.stop(render);
                gameWrapper.removeEventListener('pointerdown', handlePointerDown);
                gameWrapper.removeEventListener('pointermove', handlePointerMove);
                gameWrapper.removeEventListener('pointerup', handlePointerUp);
                headerEl.removeEventListener('pointerdown', stopToolbarEventBubbling);
                headerEl.removeEventListener('pointermove', stopToolbarEventBubbling);
                headerEl.removeEventListener('pointerup', stopToolbarEventBubbling);
                restartButton.removeEventListener('click', handleRestart);
                restartMenuButton.removeEventListener('click', handleRestartFromMenu);
                restartConfirmYes.removeEventListener('click', confirmRestart);
                restartConfirmNo.removeEventListener('click', cancelRestart);
                burgerMenuButton.removeEventListener('click', togglePauseMenu);
                resumeButton.removeEventListener('click', togglePauseMenu);
                musicToggle.removeEventListener('click', toggleMusic);
                soundsToggle.removeEventListener('click', toggleSounds); 
                Events.off(engine);
                Events.off(render);
                World.clear(world, false);
                Composite.clear(world, false, true);
                Engine.clear(engine);
                if (render.canvas) {
                    render.canvas.remove();
                }
                initGame(); 
            }

            
            // --- Utility Functions ---
            function updateScore(newScore) {
                score = newScore;
                scoreEl.textContent = score;

                if (score > highScore) {
                    highScore = score;
                    highScoreEl.textContent = highScore;
                }
            }
            
            function triggerGameOver() {
                if (isGameOver) return; 
                isGameOver = true;
                
                // Play game over sound effect
                playGameOverSound();
                
                // Fade out background music
                stopBackgroundMusic();

                // Remove the bottom wall to let fruits fall
                const groundWall = Composite.allBodies(world).find(body => body.label === 'ground');
                if (groundWall) {
                    World.remove(world, groundWall);
                }
                
                // Show the game over modal container (without content visible yet)
                gameOverModal.classList.remove('hidden');
                
                // Immediately fade in the "Game Over" text while fruits are falling
                setTimeout(() => {
                    gameOverText.classList.add('visible');
                }, 50);
                
                // Let the fruits fall for 2 seconds, then show modal content
                setTimeout(() => {
                    finalScoreEl.textContent = score;

                    localStorage.setItem(HIGHSCORE_KEY, highScore.toString());
                    localStorage.removeItem(GAME_STATE_KEY);

                    // Fade in the modal background, score, and restart button
                    gameOverContent.classList.add('visible');
                }, 2000);
                
                // Keep the game running for a few more seconds to ensure all fruits fall off screen
                setTimeout(() => {
                    Runner.stop(runner);
                }, 5000);
            }

            // --- Handle Window Resize ---
            function handleResize(newWidth, newHeight) {
                if (!newWidth || !newHeight || newWidth === boxWidth) {
                    return;
                }
                
                // Calculate the scale factor
                const oldWidth = boxWidth;
                const oldHeight = boxHeight;
                const resizeScale = newWidth / oldWidth;
                
                // Update dimensions
                headerHeight = headerEl.clientHeight;
                boxWidth = newWidth;
                boxHeight = newHeight - headerHeight;
                
                scaleFactor = boxWidth / NATIVE_WIDTH;
                wallThickness = BASE_WALL_THICKNESS * scaleFactor;
                
                canvasWrapper.style.top = `${headerHeight}px`;
                canvasWrapper.style.height = `${boxHeight}px`;
                confettiContainer.style.top = `${headerHeight}px`;
                confettiContainer.style.height = `${boxHeight}px`;
                
                gameOverLineY = boxHeight * GAME_OVER_LINE_Y_PERCENT;
                dropAreaY = boxHeight * DROP_AREA_Y_PERCENT;
                
                // Update the canvas dimensions
                if (render && render.canvas) {
                    render.canvas.width = boxWidth;
                    render.canvas.height = boxHeight;
                    render.options.width = boxWidth;
                    render.options.height = boxHeight;
                    render.bounds.max.x = boxWidth;
                    render.bounds.max.y = boxHeight;
                }
                
                // Scale all existing bodies
                if (world) {
                    const allBodies = Composite.allBodies(world);
                    const staticBodiesToRemove = [];
                    const fruitBodies = [];
                    
                    // Collect bodies and scale dynamic bodies
                    allBodies.forEach(body => {
                        if (body.label === 'fruit') {
                            fruitBodies.push(body);
                            
                            // Scale position
                            Body.setPosition(body, {
                                x: body.position.x * resizeScale,
                                y: body.position.y * resizeScale
                            });
                            
                            // Scale velocity
                            Body.setVelocity(body, {
                                x: body.velocity.x * resizeScale,
                                y: body.velocity.y * resizeScale
                            });
                            
                            // Scale the fruit body
                            const fruitData = FRUITS[body.fruitLevel];
                            const newScaledRadius = fruitData.baseRadius * scaleFactor;
                            const oldScaledRadius = fruitData.baseRadius * (oldWidth / NATIVE_WIDTH);
                            const scaleRatio = newScaledRadius / oldScaledRadius;
                            
                            Body.scale(body, scaleRatio, scaleRatio);
                        } else if (body.isStatic) {
                            // Mark static bodies for removal
                            staticBodiesToRemove.push(body);
                        }
                    });
                    
                    // Remove old static bodies
                    staticBodiesToRemove.forEach(body => {
                        World.remove(world, body);
                    });
                    
                    // Recreate static bodies with new dimensions
                    const wallOptions = {
                        isStatic: true,
                        restitution: 0.1,
                        friction: 0.2,
                        render: { fillStyle: '#b45309' }
                    };
                    
                    // Only add ground wall if game is not over
                    if (!isGameOver) {
                        World.add(world, Bodies.rectangle(
                            boxWidth / 2, 
                            boxHeight - wallThickness / 2, 
                            boxWidth, 
                            wallThickness, 
                            { ...wallOptions, label: 'ground' }
                        ));
                    }
                    
                    World.add(world, [
                        Bodies.rectangle(
                            wallThickness / 2, 
                            boxHeight / 2, 
                            wallThickness, 
                            boxHeight, 
                            { ...wallOptions, label: 'wall-left' }
                        ),
                        Bodies.rectangle(
                            boxWidth - wallThickness / 2, 
                            boxHeight / 2, 
                            wallThickness, 
                            boxHeight, 
                            { ...wallOptions, label: 'wall-right' }
                        )
                    ]);
                    
                    // Recreate game over line
                    const gameOverLine = Bodies.rectangle(
                        boxWidth / 2,
                        gameOverLineY,
                        boxWidth,
                        2,
                        {
                            isStatic: true,
                            isSensor: true,
                            label: 'gameOverLine',
                            render: { fillStyle: '#FF0000', opacity: 0.5 }
                        }
                    );
                    World.add(world, gameOverLine);
                }
                
                // Update preview fruit position and size
                currentPreviewX = currentPreviewX * resizeScale;
                if (!isGameOver && !isDropping) {
                    spawnCurrentFruit();
                }
                
                // Save the updated game state
                if (!isGameOver && world && Composite.allBodies(world).length > 0) {
                    saveGameState();
                }
            }
            
            function setupResizeObserver() {
                const resizeObserver = new ResizeObserver(entries => {
                    for (let entry of entries) {
                        if (entry.target === gameWrapper) {
                            const newWidth = entry.contentRect.width;
                            const newHeight = entry.contentRect.height;
                            
                            // Handle resize without reinitializing
                            handleResize(newWidth, newHeight);
                        } else if (entry.target === fruitEvolutionRow) {
                            // Rescale icons when row size changes
                            scaleEvolutionIcons();
                        }
                    }
                });
                
                resizeObserver.observe(gameWrapper);
                resizeObserver.observe(fruitEvolutionRow);
            }
            
            // --- Handle Page Visibility/Focus Changes ---
            function setupVisibilityHandlers() {
                // Handle page visibility changes (tab switching)
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden) {
                        // Page lost focus/visibility
                        if (bgmController && bgmController.isPlaying()) {
                            bgmController.pause();
                            isMusicPaused = true;
                        }
                    } else {
                        // Page gained focus/visibility
                        if (isMusicEnabled && pauseModal.classList.contains('hidden') && !isGameOver) {
                            resumeBackgroundMusic();
                        }
                    }
                });
                
                // Handle window focus/blur events (app switching)
                window.addEventListener('blur', () => {
                    if (bgmController && bgmController.isPlaying()) {
                        bgmController.pause();
                        isMusicPaused = true;
                    }
                });
                
                window.addEventListener('focus', () => {
                    if (isMusicEnabled && pauseModal.classList.contains('hidden') && !isGameOver) {
                        resumeBackgroundMusic();
                    }
                });
            }
            
            // --- Setup Pause Modal ---
            function setupPauseModal() {
                // Set initial button text based on saved game
                if (localStorage.getItem(GAME_STATE_KEY)) {
                    resumeButton.textContent = 'Resume';
                    restartMenuButton.classList.remove('hidden');
                } else {
                    resumeButton.textContent = 'Start';
                    restartMenuButton.classList.add('hidden');
                }
                
                // Initialize audio toggle states
                musicStatus.textContent = isMusicEnabled ? 'On' : 'Off';
                soundsStatus.textContent = areSoundsEnabled ? 'On' : 'Off';
                
                // Modal is visible by default on first load
                // The togglePauseMenu function handles showing/hiding and music control
            }
        
        }; // End of window.onload
    </script>
</body>
</html>
