<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Fruit Merge Game</title>
    
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Matter.js Physics Engine -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <!-- Load Tone.js Audio Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden; /* Prevent scrolling */
            -webkit-touch-callout: none; /* Disable callouts, image save, etc */
            -webkit-user-select: none; /* Disable selection */
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            font-family: 'Inter', sans-serif;
        }
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        
        #game-container {
            touch-action: none; /* Disable panning/zooming gestures */
            -webkit-tap-highlight-color: rgba(0,0,0,0); /* Disable tap highlight */
        }

        /* Prevent scrolling on modal */
        .modal-open {
            overflow: hidden;
            height: 100%;
        }
        
        /* Line above which game ends */
        .deadline {
            position: absolute;
            left: 0;
            right: 0;
            border-bottom: 2px dashed rgba(255, 0, 0, 0.5);
            z-index: 10;
        }

        /* Next fruit indicator line */
        .indicator-line {
            position: absolute;
            top: 0; /* Positioned by JS */
            left: 50%; /* Centered */
            width: 2px;
            height: 30px;
            background: linear-gradient(to bottom, rgba(255,255,255,0.5), rgba(255,255,255,0));
            transform: translateX(-50%);
            z-index: 20;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .indicator-line.visible {
            opacity: 1;
        }

    </style>
</head>
<body class="bg-gray-900 text-white font-sans overflow-hidden">

    <!-- Header -->
    <div id="header" class="fixed top-0 left-0 right-0 z-50 p-4 flex justify-between items-center bg-gray-900/80 backdrop-blur-sm">
        <div class="flex items-center space-x-4">
            <div>
                <span class="text-xs text-gray-400 block">SCORE</span>
                <span id="score" class="text-2xl font-bold">0</span>
            </div>
            <div>
                <span class="text-xs text-gray-400 block">BEST</span>
                <span id="high-score" class="text-2xl font-bold">0</span>
            </div>
        </div>
        <div class="text-right">
            <span class="text-xs text-gray-400 block">NEXT</span>
            <div id="next-fruit-container" class="w-10 h-10 rounded-full transition-transform duration-300 ease-out"></div>
        </div>
    </div>

    <!-- Game Over Modal -->
    <div id="game-over-modal" class="hidden fixed inset-0 bg-black/70 z-[100] flex items-center justify-center p-4">
        <div class="bg-gray-800 rounded-lg p-8 text-center shadow-xl">
            <h2 class="text-3xl font-bold mb-4">Game Over</h2>
            <p class="text-lg mb-2">Your Score:</p>
            <p id="final-score" class="text-4xl font-bold mb-8">0</p>
            <button id="restart-button" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg text-lg transition-colors">
                Play Again
            </button>
        </div>
    </div>

    <!-- Confirm Restart Modal -->
    <div id="confirm-restart-modal" class="hidden fixed inset-0 bg-black/70 z-[100] flex items-center justify-center p-4">
        <div class="bg-gray-800 rounded-lg p-8 text-center shadow-xl max-w-sm w-full">
            <h2 class="text-2xl font-bold mb-4">Restart Game?</h2>
            <p class="text-md mb-6 text-gray-300">Your current game progress will be lost.</p>
            <div class="flex space-x-4">
                <button id="confirm-restart-no" class="flex-1 bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-6 rounded-lg text-lg transition-colors">
                    Cancel
                </button>
                <button id="confirm-restart-yes" class="flex-1 bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-lg text-lg transition-colors">
                    Restart
                </button>
            </div>
        </div>
    </div>
    

    <!-- Game Container -->
    <div id="game-container" class="absolute inset-0">
        <!-- The deadline line will be injected here by JS -->
    </div>
    <!-- The indicator line will be injected here by JS -->


    <script>
        (function() {
            'use strict';

            // --- Matter.js Modules ---
            const Engine = Matter.Engine;
            const Render = Matter.Render;
            const Runner = Matter.Runner;
            const Bodies = Matter.Bodies;
            const Composite = Matter.Composite;
            const Events = Matter.Events;
            const Body = Matter.Body;

            // --- Game Configuration ---
            const FRUITS = [
                { name: 'cherry', radius: 12, color: '#FF0000', score: 1 },    // 0
                { name: 'strawberry', radius: 16, color: '#FF4500', score: 2 }, // 1
                { name:A: 'grape', radius: 20, color: '#800080', score: 3 },     // 2
                { name: 'kiwi', radius: 25, color: '#8B4513', score: 4 },    // 3
                { name: 'orange', radius: 30, color: '#FFA500', score: 5 },    // 4
                { name: 'apple', radius: 38, color: '#DC143C', score: 6 },     // 5
                { name: 'peach', radius: 45, color: '#FFC0CB', score: 7 },    // 6
                { name: 'pineapple', radius: 55, color: '#FFD700', score: 8 },   // 7
                { name: 'melon', radius: 65, color: '#008000', score: 9 },      // 8
                { name: 'watermelon', radius: 80, color: '#32CD32', score: 10 },   // 9
                // Max merge
                { name: 'coconut', radius: 100, color: '#A52A2A', score: 11 },   // 10
            ];
            const MAX_FRUIT_INDEX = FRUITS.length - 1;
            const STARTING_FRUITS_MAX_INDEX = 4; // Max index for randomly spawned fruits (Orange)
            const DEADLINE_Y_RATIO = 0.18; // 18% from the top
            const HIGHSCORE_KEY = 'fruitMergeHighScore';

            // --- DOM Elements ---
            let gameContainer, nextFruitContainer, scoreEl, highScoreEl, gameOverModal, finalScoreEl, restartButton, deadlineLine, indicatorLine, confirmRestartModal, confirmRestartYes, confirmRestartNo;

            // --- Matter.js ---
            let engine, render, runner;

            // --- Game State ---
            let currentFruitBody = null;
            let currentFruitIndex = 0;
            let nextFruitIndex = 0;
            let score = 0;
            let highScore = 0;
            let disableDrop = false;
            let bodiesToRemoveSet = new Set();
            let bodiesToAddArray = [];

            // --- Audio ---
            let mergeSynth; // Will be initialized on start

            // --- Game Dimensions (will be set in initGame) ---
            let headerHeight = 0;
            let boxWidth = 0;
            let boxHeight = 0;
            let deadlineY = 0;
            let wallThickness = 50;

            // --- Initialization ---
            window.onload = initGame;

            function initGame() {
                // --- Setup DOM elements ---
                gameContainer = document.getElementById('game-container');
                nextFruitContainer = document.getElementById('next-fruit-container');
                scoreEl = document.getElementById('score');
                highScoreEl = document.getElementById('high-score');
                gameOverModal = document.getElementById('game-over-modal');
                finalScoreEl = document.getElementById('final-score');
                restartButton = document.getElementById('restart-button');
                confirmRestartModal = document.getElementById('confirm-restart-modal');
                confirmRestartYes = document.getElementById('confirm-restart-yes');
                confirmRestartNo = document.getElementById('confirm-restart-no');

                // --- Setup Game Dimensions ---
                setupGameDimensions();

                // --- Setup Matter.js ---
                engine = createNewEngine();
                render = createNewRenderer(engine);
                runner = createNewRunner();
                
                // Add initial walls for the first load
                addWalls(engine);

                // --- Setup Event Listeners ---
                
                restartButton.addEventListener('click', () => {
                    // Show confirm modal instead of direct restart
                    confirmRestartModal.classList.remove('hidden');
                    document.body.classList.add('modal-open');
                });
                
                confirmRestartYes.addEventListener('click', () => {
                    // Safely start audio context
                    try {
                        if (typeof Tone !== 'undefined' && Tone.context.state !== 'running') {
                            Tone.start();
                        }
                    } catch (e) {
                        console.error("Failed to start audio context:", e);
                    }
                    startGame(); // Start a new game
                });

                confirmRestartNo.addEventListener('click', () => {
                    confirmRestartModal.classList.add('hidden');
                    document.body.classList.remove('modal-open');
                });

                // --- Start rendering ---
                Matter.Render.run(render);
                
                // --- MODIFICATION: DO NOT START THE RUNNER HERE ---
                // Matter.Runner.run(runner, engine); <-- REMOVED
                
                // --- Start the game immediately ---
                // Safely start audio context
                try {
                    if (typeof Tone !== 'undefined' && Tone.context.state !== 'running') {
                        Tone.start();
                    }
                } catch (e) {
                    console.error("Failed to start audio context:", e);
                }
                startGame();
            }

            function setupGameDimensions() {
                headerHeight = document.getElementById('header').offsetHeight;
                boxWidth = Math.min(window.innerWidth, 450); // Max width for game area
                boxHeight = window.innerHeight;

                // Adjust game container size and position
                gameContainer.style.width = `${boxWidth}px`;
                gameContainer.style.height = `${boxHeight}px`;
                gameContainer.style.position = 'absolute';
                gameContainer.style.top = '0';
                gameContainer.style.left = '50%';
                gameContainer.style.transform = 'translateX(-50%)';
                
                deadlineY = boxHeight * DEADLINE_Y_RATIO;
                
                // Inject deadline line
                if (!deadlineLine) {
                    deadlineLine = document.createElement('div');
                    deadlineLine.className = 'deadline';
                    gameContainer.appendChild(deadlineLine);
                }
                deadlineLine.style.top = `${deadlineY}px`;
                
                // Inject indicator line
                if (!indicatorLine) {
                    indicatorLine = document.createElement('div');
                    indicatorLine.className = 'indicator-line';
                    gameContainer.appendChild(indicatorLine);
                }
                indicatorLine.style.top = `${headerHeight}px`;
            }

            // --- Extracted functions to create engine components ---
            
            function createNewEngine() {
                return Engine.create({
                    gravity: { y: 0.6 },
                    timing: { timeScale: 1 }
                });
            }

            function createNewRenderer(engine) {
                return Render.create({
                    element: gameContainer,
                    engine: engine,
                    options: {
                        width: boxWidth,
                        height: boxHeight,
                        wireframes: false,
                        background: 'transparent',
                        pixelRatio: window.devicePixelRatio,
                        showAngleIndicator: false,
                    }
                });
            }

            function createNewRunner() {
                return Matter.Runner.create();
            }

            function addWalls(engineInstance) {
                const ground = createWall(boxWidth / 2, boxHeight + wallThickness / 2, boxWidth, wallThickness);
                const leftWall = createWall(-wallThickness / 2, boxHeight / 2, wallThickness, boxHeight * 2); // Extra high
                const rightWall = createWall(boxWidth + wallThickness / 2, boxHeight / 2, wallThickness, boxHeight * 2); // Extra high
                Composite.add(engineInstance.world, [ground, leftWall, rightWall]);
            }

            function createWall(x, y, width, height) {
                return Bodies.rectangle(x, y, width, height, {
                    isStatic: true,
                    render: { fillStyle: 'transparent' } // Walls are invisible
                });
            }

            // --- Game Logic ---
            
            // --- Universal Start/Restart Function ---
            function startGame() {
                
                // 1. Hide all overlays
                confirmRestartModal.classList.add('hidden');
                gameOverModal.classList.add('hidden');
                document.body.classList.remove('modal-open');

                // 2. Stop the runner (in case it's a restart)
                if (runner && runner.enabled) {
                    Matter.Runner.stop(runner);
                }
                
                // 3. Clear all bodies (fruits, old walls)
                Composite.clear(engine.world, false);
                
                // 4. Re-add walls to the clean world
                addWalls(engine);

                // 5. Reset game state variables
                score = 0;
                updateScore(0);
                
                highScore = parseInt(localStorage.getItem(HIGHSCORE_KEY) || '0');
                highScoreEl.textContent = highScore;
                
                // 6. Safely initialize audio synth
                if (!mergeSynth && typeof Tone !== 'undefined' && Tone.PolySynth && Tone.Synth) {
                    try {
                        mergeSynth = new Tone.PolySynth(Tone.Synth, {
                            oscillator: { type: 'triangle' },
                            envelope: {
                                attack: 0.01,
                                decay: 0.1,
                                sustain: 0,
                                release: 0.1
                            }
                        }).toDestination();
                    } catch (e) {
                        console.error("Failed to initialize audio synth:", e);
                        mergeSynth = null;
                    }
                }
                
                bodiesToRemoveSet.clear();
                bodiesToAddArray = [];
                currentFruitBody = null; // Ensure no ghost fruit

                // 7. Reset physics event listeners
                Events.off(engine, 'collisionStart', handleCollision);
                Events.off(engine, 'afterUpdate', processMergesAndCheckGameOver);
                Events.on(engine, 'collisionStart', handleCollision);
                Events.on(engine, 'afterUpdate', processMergesAndCheckGameOver);

                // 8. MODIFICATION: Start the physics runner HERE.
                // This command both associates the runner and engine AND starts it.
                Matter.Runner.run(runner, engine);

                // 9. Spawn the first fruit
                nextFruitIndex = Math.floor(Math.random() * STARTING_FRUITS_MAX_INDEX);
                spawnNextFruit();
            }

            function spawnNextFruit() {
                currentFruitIndex = nextFruitIndex;
                nextFruitIndex = Math.floor(Math.random() * STARTING_FRUITS_MAX_INDEX);

                updateNextFruitDisplay(FRUITS[nextFruitIndex]);

                const fruit = FRUITS[currentFruitIndex];
                const x = boxWidth / 2; // Start in center
                const y = headerHeight + fruit.radius;

                currentFruitBody = createFruitBody(x, y, currentFruitIndex);
                Composite.add(engine.world, currentFruitBody);
                
                // Show indicator line
                indicatorLine.style.left = `${x}px`;
                indicatorLine.classList.add('visible');

                // Add pointer event listeners
                gameContainer.addEventListener('pointerdown', handlePointerDown);
                gameContainer.addEventListener('pointermove', handlePointerMove);
                gameContainer.addEventListener('pointerup', handlePointerUp);
                
                disableDrop = false;
            }

            function createFruitBody(x, y, index) {
                const fruit = FRUITS[index];
                return Bodies.circle(x, y, fruit.radius, {
                    label: 'fruit',
                    isStatic: true, // Starts static
                    restitution: 0.3,
                    friction: 0.1,
                    density: 0.001,
                    render: {
                        fillStyle: fruit.color,
                        strokeStyle: 'rgba(0,0,0,0.2)',
                        lineWidth: 2
                    },
                    // Custom properties
                    fruitIndex: index,
                    fruitName: fruit.name
                });
            }
            
            function moveFruit(pointerX) {
                if (!currentFruitBody || disableDrop) return;
                
                const fruit = FRUITS[currentFruitIndex];
                // Constrain X to be within walls, considering fruit radius
                const containerRect = gameContainer.getBoundingClientRect();
                const x = pointerX - containerRect.left; // x relative to game container
                
                const clampedX = Math.max(
                    fruit.radius, 
                    Math.min(boxWidth - fruit.radius, x)
                );
                
                Body.setPosition(currentFruitBody, { x: clampedX, y: currentFruitBody.position.y });
                
                // Update indicator line
                indicatorLine.style.left = `${clampedX}px`;
            }

            function dropFruit() {
                if (!currentFruitBody || disableDrop) return;
                
                disableDrop = true; // Prevent multiple drops
                
                // Make it dynamic
                Body.setStatic(currentFruitBody, false);
                
                // Remove indicator
                indicatorLine.classList.remove('visible');
                
                // Remove pointer event listeners
                gameContainer.removeEventListener('pointerdown', handlePointerDown);
                gameContainer.removeEventListener('pointermove', handlePointerMove);
                gameContainer.removeEventListener('pointerup', handlePointerUp);
                
                currentFruitBody = null; // We no longer control this fruit

                // Spawn next fruit after a short delay
                setTimeout(spawnNextFruit, 600);
            }

            // --- Event Handlers (to allow removal) ---
            function handlePointerDown(e) { 
                e.preventDefault(); 
                
                // Safely start audio context
                try {
                    if (typeof Tone !== 'undefined' && Tone.context && Tone.context.state !== 'running') {
                        Tone.start();
                    }
                } catch (e) {
                    console.error("Failed to start audio context:", e);
                }
                
                moveFruit(e.clientX); 
            }
            function handlePointerMove(e) { e.preventDefault(); moveFruit(e.clientX); }
            function handlePointerUp(e) { e.preventDefault(); dropFruit(); }
            

            function handleCollision(event) {
                if (!engine || !event.pairs) return;

                const pairs = event.pairs;
                for (let i = 0; i < pairs.length; i++) {
                    const pair = pairs[i];
                    const { bodyA, bodyB } = pair;

                    if (bodyA.label === 'fruit' && bodyB.label === 'fruit' &&
                        bodyA.fruitIndex === bodyB.fruitIndex && // Same fruit type
                        bodyA.fruitIndex < MAX_FRUIT_INDEX && // Not the max fruit
                        !bodiesToRemoveSet.has(bodyA) && // Not already marked for removal
                        !bodiesToRemoveSet.has(bodyB)) 
                    {
                        // Mark for removal
                        bodiesToRemoveSet.add(bodyA);
                        bodiesToRemoveSet.add(bodyB);

                        // Schedule new fruit to be added
                        const newIndex = bodyA.fruitIndex + 1;
                        const newX = (bodyA.position.x + bodyB.position.m.y) / 2;
                        const newY = (bodyA.position.y + bodyB.position.y) / 2;
                        
                        bodiesToAddArray.push({ x: newX, y: newY, index: newIndex });
                        
                        // Update score
                        updateScore(FRUITS[newIndex].score);
                    }
                }
            }
            
            function processMergesAndCheckGameOver() {
                if (!engine || !engine.world) return;
                
                let didMerge = false;
                
                // 1. Process merges (add/remove bodies)
                if (bodiesToRemoveSet.size > 0 || bodiesToAddArray.length > 0) {
                    
                    // Remove bodies
                    bodiesToRemoveSet.forEach(body => {
                        Composite.remove(engine.world, body);
                    });
                    
                    // Add new bodies
                    bodiesToAddArray.forEach(item => {
                        const newBody = createFruitBody(item.x, item.y, item.index);
                        Body.setStatic(newBody, false); // Make sure it's dynamic
                        Composite.add(engine.world, newBody);
                        didMerge = true;
                    });
                    
                    if (didMerge && navigator.vibrate) {
                        navigator.vibrate(50); 
                    }

                    // Safely play merge sound
                    if (didMerge && mergeSynth) {
                        try {
                            const now = Tone.now();
                            mergeSynth.triggerAttackRelease("C4", "8n", now);
                            mergeSynth.triggerAttackRelease("E4", "8n", now + 0.05);
                            mergeSynth.triggerAttackRelease("G4", "8n", now + 0.1);
                        } catch (e) {
                            console.error("Failed to play merge sound:", e);
                        }
                    }

                    bodiesToRemoveSet.clear();
                    bodiesToAddArray = [];
                }

                // 2. Check for Game Over
                if (disableDrop) { // Only check if a fruit is falling or has landed
                    const bodies = Composite.allBodies(engine.world);
                    for (let i = 0; i < bodies.length; i++) {
                        const body = bodies[i];
                        if (body.label === 'fruit' && !body.isStatic) {
                            // Check if the top of the fruit is above the deadline
                            if (body.position.y - body.circleRadius < deadlineY) {
                                // Check if it's "settled" (moving slowly)
                                if (body.velocity.x < 0.1 && body.velocity.y < 0.1) {
                                    endGame();
                                    return; // Stop checking
                                }
                            }
                        }
                    }
                }
            }

            function updateScore(pointsToAdd) {
                if (pointsToAdd > 0) {
                    score += pointsToAdd;
                } else {
                    score = 0; // Reset score
                }
                scoreEl.textContent = score;

                if (score > highScore) {
                    highScore = score;
                    highScoreEl.textContent = highScore;
                    localStorage.setItem(HIGHSCORE_KEY, highScore);
                }
            }
            
            function updateNextFruitDisplay(fruit) {
                nextFruitContainer.style.backgroundColor = fruit.color;
                nextFruitContainer.style.width = `${fruit.radius * 2 * 0.4}px`; // Scale down for display
                nextFruitContainer.style.height = `${fruit.radius * 2 * 0.4}px`;
            }

            // --- Simplified endGame ---
            function endGame() {
                // 1. Stop the physics runner
                if (runner) {
                    Matter.Runner.stop(runner);
                }
                
                // 2. Stop physics events
                Events.off(engine, 'collisionStart', handleCollision);
                Events.off(engine, 'afterUpdate', processMergesAndCheckGameOver);
                
                // 3. Remove event listeners
                gameContainer.removeEventListener('pointerdown', handlePointerDown);
                gameContainer.removeEventListener('pointermove', handlePointerMove);
                gameContainer.removeEventListener('pointerup', handlePointerUp);

                // 4. Show Game Over modal
                finalScoreEl.textContent = score;
                gameOverModal.classList.remove('hidden');
                document.body.classList.add('modal-open');
                
                // 5. Hide indicator line
                if (indicatorLine) {
                    indicatorLine.classList.remove('visible');
                }
                
                // 6. Clear any remaining floating fruit
                if (currentFruitBody) {
                    Composite.remove(engine.world, currentFruitBody);
                    currentFruitBody = null;
                }
            }
            
            // Handle window resize
            let resizeTimeout;
            window.onresize = () => {
                // Debounce resize
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(()re) => {
                    // Re-setup dimensions
                    setupGameDimensions();
                    
                    // Update renderer
                    render.options.width = boxWidth;
                    render.options.height = boxHeight;
                    if (render.canvas) {
                        render.canvas.width = boxWidth * window.devicePixelRatio;
                        render.canvas.height = boxHeight * window.devicePixelRatio;
                        render.canvas.style.width = `${boxWidth}px`;
                        render.canvas.style.height = `${boxHeight}px`;
                    }

                    // We need to restart the game as wall positions depend on dimensions
                    endGame();
                    // Put user back on the "game over" screen, from which they can restart
                    finalScoreEl.textContent = score;
                    gameOverModal.classList.remove('hidden');
                    document.body.classList.add('modal-open');
                }, 250);
            };

        })();
    </script>
</body>
</html>


