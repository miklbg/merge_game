<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Fruit Merge Game</title>
    
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Matter.js Physics Engine -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    
    <style>
        html, body {
            overflow: hidden;
            height: 100%;
            width: 100%;
            font-family: 'Inter', sans-serif;
            touch-action: none; 
            /* --- FIX: Bright background --- */
            background-color: #e0f2fe; /* bg-sky-100 */
        }
        
        body {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #game-wrapper {
            display: flex;
            flex-direction: column;
            /* --- FIX: Enforce 2:3 aspect ratio --- */
            aspect-ratio: 2 / 3;
            /* Use either max-width or max-height to constrain, let aspect-ratio determine the other */
            width: min(100vw, 100vh * 2 / 3);
            height: min(100vh, 100vw * 3 / 2);
            /* --- FIX: Bright wrapper background --- */
            background-color: #fff7ed; /* bg-orange-50 */
            overflow: hidden;
            position: relative;
            
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        #game-header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            z-index: 20;
        }
        
        #preview-fruit {
            position: absolute;
            left: 50%;
            z-index: 10;
            pointer-events: none;
            opacity: 0.8;
            border: 2px dashed rgba(0, 0, 0, 0.3); /* Darker dash for light bg */
            
            border-radius: 0;
            
            display: flex;
            justify-content: center;
            align-items: center;
            text-shadow: 0 0 5px rgba(0,0,0,0.2);
            backface-visibility: hidden;
        }

        #game-canvas-wrapper {
            position: absolute;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 1;
        }
        
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        #loading-screen {
            position: absolute;
            inset: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            /* --- FIX: Bright loading screen --- */
            background-color: #fff7ed; /* bg-orange-50 */
            z-index: 99;
            font-size: 1.5rem;
            color: #1f2937; /* text-gray-800 */
            font-weight: 500;
        }

        #start-modal {
            transition: opacity 0.3s ease, transform 0.3s ease;
            pointer-events: auto;
        }

        #start-modal.hidden {
            opacity: 0;
            transform: scale(0.9);
            pointer-events: none;
        }

        #game-over-modal {
            transition: opacity 0.3s ease, transform 0.3s ease;
            pointer-events: auto;
        }

        #game-over-modal.hidden {
            opacity: 0;
            transform: scale(0.9);
            pointer-events: none;
        }

        #restart-confirm-modal {
            transition: opacity 0.3s ease, transform 0.3s ease;
            pointer-events: auto;
        }

        #restart-confirm-modal.hidden {
            opacity: 0;
            transform: scale(0.9);
            pointer-events: none;
        }

        #confetti-container {
            position: absolute;
            inset: 0;
            pointer-events: none;
            overflow: hidden;
            z-index: 15; 
        }
        .confetti-piece {
            position: absolute;
            background-color: white; 
            border-radius: 50%;
            opacity: 1;
            transition: transform 0.8s ease-out, opacity 0.8s ease-out;
        }
    </style>
</head>
<!-- --- FIX: Bright body classes --- -->
<body class="bg-sky-100 text-gray-800">

    <div id="game-wrapper">
        
        <div id="loading-screen">Loading...</div>

        <!-- Start/Resume Modal -->
        <div id="start-modal" class="absolute inset-0 bg-white/70 text-gray-900 backdrop-blur-md z-30 flex flex-col justify-center items-center text-center p-8">
            <h2 class="text-5xl font-bold text-orange-500 mb-8">Fruit Merge Game</h2>
            <button id="start-resume-button" class="px-8 py-4 bg-green-500 text-white font-bold rounded-lg shadow-lg text-2xl hover:bg-green-400 transition-all">
                Start
            </button>
        </div>

        <!-- --- FIX: Bright header --- -->
        <div id="game-header" class="p-4 flex justify-between items-center bg-white/50 backdrop-blur-sm">
            <div class="flex gap-4">
                <div>
                    <span class="text-sm opacity-80">Score</span>
                    <div id="score" class="text-2xl font-bold">0</div>
                </div>
                <div>
                    <span class="text-sm opacity-80">High Score</span>
                    <div id="high-score" class="text-2xl font-bold">0</div>
                </div>
            </div>
            <div class="text-right">
                <div class="flex items-center gap-4">
                    <div>
                        <span class="text-sm opacity-80">Next</span>
                        <div id="next-fruit" class="text-3xl"></div>
                    </div>
                    <!-- Restart Icon Button -->
                    <button id="new-game-button" class="p-2 bg-transparent hover:bg-orange-100 rounded-lg transition-all group" title="Restart Game" aria-label="Restart Game">
                        <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-orange-600 group-hover:text-orange-700 transition-colors">
                            <path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.2"/>
                        </svg>
                    </button>
                </div>
            </div>
        </div>
        
        <div id="preview-fruit"></div>
        <div id="game-canvas-wrapper"></div>
        <div id="confetti-container"></div>

        <!-- --- FIX: Bright game over modal --- -->
        <div id="game-over-modal" class="hidden absolute inset-0 bg-white/70 text-gray-900 backdrop-blur-md z-20 flex flex-col justify-center items-center text-center p-8">
            <h2 class="text-5xl font-bold text-red-500 mb-4">Game Over</h2>
            <p class="text-xl mb-2">Final Score:</p>
            <div id="final-score" class="text-4xl font-bold mb-8">0</div>
            <!-- --- FIX: Playful button color --- -->
            <button id="restart-button" class="px-6 py-3 bg-green-500 text-white font-bold rounded-lg shadow-lg text-xl hover:bg-green-400 transition-all">
                Restart
            </button>
        </div>

        <!-- Restart Confirmation Modal -->
        <div id="restart-confirm-modal" class="hidden absolute inset-0 bg-white/70 text-gray-900 backdrop-blur-md z-40 flex flex-col justify-center items-center text-center p-8">
            <h2 class="text-3xl font-bold text-orange-600 mb-4">Restart Game?</h2>
            <p class="text-lg mb-8">Your current progress will be lost.</p>
            <div class="flex gap-4">
                <button id="restart-confirm-yes" class="px-6 py-3 bg-red-500 text-white font-bold rounded-lg shadow-lg text-xl hover:bg-red-400 transition-all">
                    Yes, Restart
                </button>
                <button id="restart-confirm-no" class="px-6 py-3 bg-gray-500 text-white font-bold rounded-lg shadow-lg text-xl hover:bg-gray-400 transition-all">
                    Cancel
                </button>
            </div>
        </div>
    </div>

    <script type="module">
        // Import Web Audio BGM controller
        import { createBgmController } from './audio/web-audio-bgm.js';

        // Wait for the *entire page* to load
        window.onload = () => {
            
            // --- DOM Elements ---
            const gameWrapper = document.getElementById('game-wrapper');
            const headerEl = document.getElementById('game-header');
            const canvasWrapper = document.getElementById('game-canvas-wrapper');
            const loadingScreen = document.getElementById('loading-screen');
            const previewFruitEl = document.getElementById('preview-fruit');
            const confettiContainer = document.getElementById('confetti-container');
            const startModal = document.getElementById('start-modal');
            const startResumeButton = document.getElementById('start-resume-button');
            
            const scoreEl = document.getElementById('score');
            const highScoreEl = document.getElementById('high-score');
            const nextFruitEl = document.getElementById('next-fruit');
            const newGameButton = document.getElementById('new-game-button');
            const gameOverModal = document.getElementById('game-over-modal');
            const finalScoreEl = document.getElementById('final-score');
            const restartButton = document.getElementById('restart-button');
            const restartConfirmModal = document.getElementById('restart-confirm-modal');
            const restartConfirmYes = document.getElementById('restart-confirm-yes');
            const restartConfirmNo = document.getElementById('restart-confirm-no');

            // --- Matter.js modules ---
            const { Engine, Render, Runner, World, Bodies, Body, Events, Composite, Common } = Matter;

            // --- Pre-defined clip-paths for preview shapes (for CSS) ---
            const POLYGON_CLIP_PATHS = {
                'circle': 'circle(50%)',
                5: 'polygon(50% 0%, 100% 38%, 82% 100%, 18% 100%, 0% 38%)', // Pentagon
                6: 'polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%)', // Hexagon
                7: 'polygon(50% 0%, 90% 20%, 100% 60%, 75% 100%, 25% 100%, 0% 60%, 10% 20%)', // Heptagon
                8: 'polygon(50% 0%, 85% 15%, 100% 50%, 85% 85%, 50% 100%, 15% 85%, 0% 50%, 15% 15%)', // Octagon
                10: 'polygon(50% 0%, 80% 10%, 100% 35%, 100% 65%, 80% 90%, 50% 100%, 20% 90%, 0% 65%, 0% 35%, 20% 10%)' // Decagon
            };

            // --- Game Configuration ---
            
            const NATIVE_WIDTH = 400; // Our "design" width
            let scaleFactor = 1; // Will be set in initGame

            const FRUITS = [
                // Use 'baseRadius' for all pixel values - all fruits are now circles
                { level: 0, baseRadius: 22, color: '#FFB6C1', emoji: 'ðŸ’', score: 5, clipPath: POLYGON_CLIP_PATHS['circle'] },
                { level: 1, baseRadius: 26, color: '#FF6347', emoji: 'ðŸ“', score: 10, clipPath: POLYGON_CLIP_PATHS['circle'] },
                { level: 2, baseRadius: 34, color: '#FFD700', emoji: 'ðŸ‡', score: 20, clipPath: POLYGON_CLIP_PATHS['circle'] },
                { level: 3, baseRadius: 38, color: '#FF8C00', emoji: 'ðŸŠ', score: 35, clipPath: POLYGON_CLIP_PATHS['circle'] },
                { level: 4, baseRadius: 48, color: '#FF4500', emoji: 'ðŸŽ', score: 55, clipPath: POLYGON_CLIP_PATHS['circle'] },
                { level: 5, baseRadius: 58, color: '#ADFF2F', emoji: 'ðŸ', score: 80, clipPath: POLYGON_CLIP_PATHS['circle'] },
                { level: 6, baseRadius: 66, color: '#FFFF00', emoji: 'ðŸ‘', score: 110, clipPath: POLYGON_CLIP_PATHS['circle'] },
                { level: 7, baseRadius: 78, color: '#F0E68C', emoji: 'ðŸ', score: 150, clipPath: POLYGON_CLIP_PATHS['circle'] },
                { level: 8, baseRadius: 90, color: '#90EE90', emoji: 'ðŸˆ', score: 200, clipPath: POLYGON_CLIP_PATHS['circle'] },
                { level: 9, baseRadius: 102, color: '#32CD32', emoji: 'ðŸ‰', score: 300, clipPath: POLYGON_CLIP_PATHS['circle'] },
            ];

            const MAX_FRUIT_LEVEL = FRUITS.length - 1;
            const STARTING_FRUIT_LEVELS = 4;
            const GAME_OVER_LINE_Y_PERCENT = 0.18; 
            const DROP_AREA_Y_PERCENT = 0.1; 
            const BASE_WALL_THICKNESS = 40; 
            const EMOJI_SCALE_FACTOR = 1.7;
            const HIGHSCORE_KEY = 'fruit-merge-highscore';
            const GAME_STATE_KEY = 'fruit-merge-gamestate'; 

            // --- Game State ---
            let engine, render, runner, world;
            let score = 0;
            let highScore = 0; 
            let currentFruitLevel = 0;
            let nextFruitLevel = 0;
            let isGameOver = false;
            let isDropping = false; 
            let collisionTimeout = null;
            let currentPreviewX = 0; 
            let saveCounter = 0; 
            
            let bodiesToRemoveSet = new Set();
            let bodiesToAddArray = [];

            // --- Audio System ---
            // Sound effects are generated programmatically using the Web Audio API.
            // Background music is from Pixabay (see assets/README.md for details)
            // Using Web Audio API wrapper for reliable cross-browser volume control
            let audioContext = null;
            let bgmController = null;
            let isMusicPaused = false;

            function initAudioContext() {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
            }
            
            function initBackgroundMusic() {
                if (!bgmController) {
                    try {
                        // Create Web Audio BGM controller with default gain of 0.25 (~-12dB)
                        bgmController = createBgmController({
                            audioElOrSrc: 'assets/children-music-loop-creative-fun-262427.mp3',
                            defaultGain: 0.25,  // Much louder than previous 0.05, but still pleasant
                            loop: true
                        });
                        
                        // Setup unlock on user gesture for iOS Safari
                        bgmController.unlockOnUserGesture();
                        
                        console.log('Background music controller initialized');
                    } catch (error) {
                        console.warn('Background music could not be initialized:', error);
                    }
                }
            }

            // Play a drop sound effect (short descending tone)
            function playDropSound() {
                initAudioContext();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.1);
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.1);
            }

            // Play a merge sound effect (cheerful ascending chime)
            function playMergeSound() {
                initAudioContext();
                const oscillator1 = audioContext.createOscillator();
                const oscillator2 = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator1.connect(gainNode);
                oscillator2.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator1.type = 'sine';
                oscillator2.type = 'sine';
                
                oscillator1.frequency.setValueAtTime(523.25, audioContext.currentTime); // C5
                oscillator1.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.05); // E5
                oscillator1.frequency.setValueAtTime(783.99, audioContext.currentTime + 0.1); // G5
                
                oscillator2.frequency.setValueAtTime(523.25 * 2, audioContext.currentTime); // C6
                oscillator2.frequency.setValueAtTime(659.25 * 2, audioContext.currentTime + 0.05); // E6
                oscillator2.frequency.setValueAtTime(783.99 * 2, audioContext.currentTime + 0.1); // G6
                
                gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                
                oscillator1.start(audioContext.currentTime);
                oscillator2.start(audioContext.currentTime);
                oscillator1.stop(audioContext.currentTime + 0.3);
                oscillator2.stop(audioContext.currentTime + 0.3);
            }

            // Start background music
            function startBackgroundMusic() {
                initBackgroundMusic();
                if (bgmController && !isMusicPaused) {
                    bgmController.play().catch(error => {
                        console.warn('Autoplay was prevented. User interaction required.');
                    });
                }
            }

            // Stop background music with fade out
            function stopBackgroundMusic() {
                if (bgmController && bgmController.isPlaying()) {
                    isMusicPaused = true;
                    
                    // Fade out effect using Web Audio gain
                    const fadeOutInterval = setInterval(() => {
                        const currentGain = bgmController.getGainLinear();
                        if (currentGain > 0.01) {
                            bgmController.setGainLinear(currentGain - 0.01);
                        } else {
                            bgmController.pause();
                            bgmController.setGainLinear(0.25); // Reset gain for next play
                            clearInterval(fadeOutInterval);
                        }
                    }, 50);
                }
            }
            
            // Resume background music (for focus events)
            function resumeBackgroundMusic() {
                if (bgmController && isMusicPaused && !isGameOver) {
                    isMusicPaused = false;
                    bgmController.setGainLinear(0.25);
                    bgmController.play().catch(error => {
                        console.warn('Could not resume music:', error);
                    });
                }
            }

            // --- Game Dimensions (will be set in initGame) ---
            let headerHeight = 0;
            let boxWidth = 0;
            let boxHeight = 0;
            let gameOverLineY = 0;
            let dropAreaY = 0;
            let wallThickness = 40; 

            
            // --- ROBUST STARTUP ---
            const layoutCheckInterval = setInterval(() => {
                const w = gameWrapper.clientWidth;
                const h = gameWrapper.clientHeight;
                const hh = headerEl.clientHeight;
                
                if (w > 0 && h > 0 && hh > 0) {
                    clearInterval(layoutCheckInterval);
                    console.log(`Layout ready. Wrapper: ${w}x${h}, Header: ${hh}`);
                    loadingScreen.style.display = 'none';
                    initGame(); 
                    setupResizeObserver();
                    setupVisibilityHandlers();
                    setupStartModal();
                } else {
                    console.log("Waiting for layout dimensions...");
                }
            }, 50);

            // --- Game Initialization ---
            function initGame() {
                headerHeight = headerEl.clientHeight;
                boxWidth = gameWrapper.clientWidth; 
                boxHeight = gameWrapper.clientHeight - headerHeight; 
                
                scaleFactor = boxWidth / NATIVE_WIDTH;
                wallThickness = BASE_WALL_THICKNESS * scaleFactor; 
                
                canvasWrapper.style.top = `${headerHeight}px`;
                canvasWrapper.style.height = `${boxHeight}px`;
                confettiContainer.style.top = `${headerHeight}px`;
                confettiContainer.style.height = `${boxHeight}px`;

                gameOverLineY = boxHeight * GAME_OVER_LINE_Y_PERCENT;
                dropAreaY = boxHeight * DROP_AREA_Y_PERCENT;
                currentPreviewX = boxWidth / 2;

                isGameOver = false;
                isDropping = false;
                saveCounter = 0;
                
                highScore = parseInt(localStorage.getItem(HIGHSCORE_KEY) || '0');
                highScoreEl.textContent = highScore;
                
                gameOverModal.classList.add('hidden');
                
                bodiesToRemoveSet.clear();
                bodiesToAddArray = [];

                engine = Engine.create();
                world = engine.world;
                world.gravity.y = 0.8; 

                render = Render.create({
                    element: canvasWrapper, 
                    engine: engine,
                    options: {
                        width: boxWidth,
                        height: boxHeight,
                        wireframes: false,
                        /* --- FIX: Bright render background --- */
                        background: '#fff7ed' // bg-orange-50
                    }
                });

                runner = Runner.create();
                World.clear(world, false);

                const wallOptions = {
                    isStatic: true,
                    restitution: 0.1,
                    friction: 0.2,
                    /* --- FIX: Playful wall color --- */
                    render: { fillStyle: '#b45309' } // bg-amber-700
                };

                World.add(world, [
                    Bodies.rectangle(boxWidth / 2, boxHeight - wallThickness / 2, boxWidth, wallThickness, { ...wallOptions, label: 'ground' }),
                    Bodies.rectangle(wallThickness / 2, boxHeight / 2, wallThickness, boxHeight, { ...wallOptions, label: 'wall-left' }),
                    Bodies.rectangle(boxWidth - wallThickness / 2, boxHeight / 2, wallThickness, boxHeight, { ...wallOptions, label: 'wall-right' })
                ]);

                const gameOverLine = Bodies.rectangle(
                    boxWidth / 2,
                    gameOverLineY,
                    boxWidth,
                    2,
                    {
                        isStatic: true,
                        isSensor: true,
                        label: 'gameOverLine',
                        render: { fillStyle: '#FF0000', opacity: 0.5 } 
                    }
                );
                World.add(world, gameOverLine);

                const savedStateString = localStorage.getItem(GAME_STATE_KEY);
                let loadedState = null;
                if (savedStateString) {
                    try {
                        loadedState = JSON.parse(savedStateString);
                    } catch (e) {
                        console.error("Could not parse saved state:", e);
                        localStorage.removeItem(GAME_STATE_KEY); 
                    }
                }

                if (loadedState) {
                    console.log("Loading from saved state...");
                    const loadedScaleFactor = loadedState.boxWidth ? (boxWidth / loadedState.boxWidth) : 1;

                    loadedState.fruits.forEach(fruit => {
                        const body = createFruitBody(
                            fruit.x * loadedScaleFactor, 
                            fruit.y * loadedScaleFactor, 
                            fruit.level
                        );
                        
                        Body.setAngle(body, fruit.angle);
                        Body.setVelocity(body, { x: fruit.velocityX * loadedScaleFactor, y: fruit.velocityY * loadedScaleFactor });
                        Body.setAngularVelocity(body, fruit.angularVelocity);
                        World.add(world, body);
                    });
                    score = loadedState.score;
                    nextFruitLevel = loadedState.nextFruitLevel;
                    spawnCurrentFruit(); 
                    spawnNextFruit(); 
                } else {
                    console.log("Starting new game...");
                    score = 0;
                    spawnNextFruit(); 
                    spawnCurrentFruit(); 
                    spawnNextFruit(); 
                }
                updateScore(score); 


                Render.run(render);
                Runner.run(runner, engine);

                Events.on(render, 'afterRender', () => {
                    const context = render.context;
                    const bodies = Composite.allBodies(world);

                    context.save(); 
                    context.textAlign = 'center';
                    context.textBaseline = 'middle';
                    
                    bodies.forEach(body => {
                        if (body.label !== 'fruit') return;

                        const fruitData = FRUITS[body.fruitLevel];
                        if (fruitData) {
                            const scaledRadius = fruitData.baseRadius * scaleFactor;
                            const size = scaledRadius * EMOJI_SCALE_FACTOR;
                            context.font = `${size}px Arial`;
                            context.translate(body.position.x, body.position.y);
                            context.rotate(body.angle);
                            context.fillText(fruitData.emoji, 0, 0);
                            context.rotate(-body.angle);
                            context.translate(-body.position.x, -body.position.y);
                        }
                    });

                    context.restore(); 
                });
                
                addEventListeners();
            }

            // --- Fruit Creation ---
            
            function createFruitBody(x, y, level, options = {}) {
                const fruitData = FRUITS[level];
                if (!fruitData) return null;

                const bodyOptions = {
                    label: 'fruit',
                    fruitLevel: level,
                    friction: 0.3,
                    restitution: 0.2,
                    density: 0.001,
                    render: {
                        fillStyle: fruitData.color
                    },
                    ...options
                };
                
                const scaledRadius = fruitData.baseRadius * scaleFactor;
                return Bodies.circle(x, y, scaledRadius, bodyOptions);
            }

            function spawnCurrentFruit() {
                currentFruitLevel = nextFruitLevel;
                const fruitData = FRUITS[currentFruitLevel];
                const scaledRadius = fruitData.baseRadius * scaleFactor;
                
                previewFruitEl.style.width = `${scaledRadius * 2}px`;
                previewFruitEl.style.height = `${scaledRadius * 2}px`;
                previewFruitEl.style.backgroundColor = fruitData.color;
                
                previewFruitEl.style.fontSize = `${scaledRadius * EMOJI_SCALE_FACTOR}px`; 
                previewFruitEl.textContent = fruitData.emoji;
                
                previewFruitEl.style.top = `${headerHeight + dropAreaY - scaledRadius}px`;
                
                const clipPath = fruitData.clipPath || POLYGON_CLIP_PATHS['circle'];
                previewFruitEl.style.clipPath = clipPath;
                previewFruitEl.style.borderRadius = clipPath === POLYGON_CLIP_PATHS['circle'] ? '50%' : '0';

                moveFruit(currentPreviewX, true); 
            }

            function spawnNextFruit() {
                nextFruitLevel = Math.floor(Math.random() * STARTING_FRUIT_LEVELS);
                nextFruitEl.textContent = FRUITS[nextFruitLevel].emoji;
            }
            
            // --- Game Controls (for the DIV) ---

            function moveFruit(clientX, isInternalCall = false) {
                if (isGameOver) return;

                const fruitData = FRUITS[currentFruitLevel];
                const scaledRadius = fruitData.baseRadius * scaleFactor;
                let x;

                if (isInternalCall) {
                    x = clientX; 
                } else {
                    const rect = gameWrapper.getBoundingClientRect();
                    x = clientX - rect.left; 
                }
                
                const constrainedX = Math.max(
                    scaledRadius + wallThickness, // Use scaled values
                    Math.min(boxWidth - scaledRadius - wallThickness, x) // Use scaled values
                );
                
                currentPreviewX = constrainedX;
                previewFruitEl.style.transform = `translateX(${constrainedX - boxWidth / 2}px) translateX(-50%)`;
            }

            function dropFruit() {
                if (isGameOver || isDropping) return;

                isDropping = true;
                
                const droppedFruit = createFruitBody(
                    currentPreviewX, 
                    dropAreaY,
                    currentFruitLevel
                );
                
                if (!droppedFruit) {
                    isDropping = false;
                    return;
                }
                
                World.add(world, droppedFruit);
                
                // Play drop sound effect
                playDropSound();
                
                previewFruitEl.style.opacity = '0';

                if (collisionTimeout) clearTimeout(collisionTimeout);
                collisionTimeout = setTimeout(() => {
                    if (!isGameOver && droppedFruit && world.bodies.includes(droppedFruit)) {
                        if (Matter.Collision.collides(droppedFruit, world.bodies.find(b => b.label === 'gameOverLine'))) {
                            triggerGameOver();
                        }
                    }
                    collisionTimeout = null;
                }, 1500);

                setTimeout(() => {
                    if (!isGameOver) {
                        spawnCurrentFruit(); 
                        spawnNextFruit(); 
                        previewFruitEl.style.opacity = '0.8';
                        isDropping = false;
                    }
                }, 300);
            }

            // --- Confetti Effect ---
            function createConfetti(x, y, color1, color2) {
                const numPieces = 25;
                for (let i = 0; i < numPieces; i++) {
                    const piece = document.createElement('div');
                    piece.classList.add('confetti-piece');
                    
                    const randomColor = Math.random() < 0.5 ? color1 : color2;
                    piece.style.backgroundColor = randomColor;
                    
                    const pieceSize = 10 * scaleFactor;
                    piece.style.width = `${pieceSize}px`;
                    piece.style.height = `${pieceSize}px`;

                    piece.style.left = `${x}px`;
                    piece.style.top = `${y}px`;
                    
                    confettiContainer.appendChild(piece);

                    const angle = Math.random() * Math.PI * 2; 
                    const distance = (Math.random() * 70 + 40) * scaleFactor; 
                    const finalX = x + Math.cos(angle) * distance;
                    const finalY = y + Math.sin(angle) * distance;

                    setTimeout(() => {
                        piece.style.transform = `translate(${finalX - x}px, ${finalY - y}px) scale(0)`;
                        piece.style.opacity = '0';
                    }, 10); 

                    setTimeout(() => {
                        piece.remove();
                    }, 800);
                }
            }
            
            // --- Save Game State ---
            function saveGameState() {
                if (isGameOver || !world) return;

                const fruits = Composite.allBodies(world)
                    .filter(body => body.label === 'fruit')
                    .map(body => ({
                        x: body.position.x,
                        y: body.position.y,
                        level: body.fruitLevel,
                        angle: body.angle,
                        velocityX: body.velocity.x,
                        velocityY: body.velocity.y,
                        angularVelocity: body.angularVelocity
                    }));
                
                const gameState = {
                    fruits: fruits,
                    score: score,
                    nextFruitLevel: nextFruitLevel,
                    boxWidth: boxWidth // Save boxWidth for scaling on load
                };

                localStorage.setItem(GAME_STATE_KEY, JSON.stringify(gameState));
            }


            // --- Event Listeners ---
            function addEventListeners() {
                Events.off(engine, 'collisionStart');
                Events.off(engine, 'collisionStay');
                Events.off(engine, 'afterUpdate');
                
                // 1. DETECT collisions
                Events.on(engine, 'collisionStart', (event) => {
                    if (isGameOver) return;
                    const pairs = event.pairs;
                    for (let i = 0; i < pairs.length; i++) {
                        const pair = pairs[i];
                        const bodyA = pair.bodyA;
                        const bodyB = pair.bodyB;

                        if (bodyA.label !== 'fruit' || bodyB.label !== 'fruit') continue;
                        
                        if (bodiesToRemoveSet.has(bodyA.id) || bodiesToRemoveSet.has(bodyB.id)) {
                            continue;
                        }

                        if (bodyA.fruitLevel === bodyB.fruitLevel) {
                            const level = bodyA.fruitLevel;
                            if (level === MAX_FRUIT_LEVEL) continue; 
                            
                            const newX = (bodyA.position.x + bodyB.position.x) / 2;
                            const newY = (bodyA.position.y + bodyB.position.y) / 2;
                            const nextLevel = level + 1;
                            
                            bodiesToAddArray.push({
                                x: newX,
                                y: newY,
                                level: nextLevel,
                                score: FRUITS[level].score,
                                color1: FRUITS[level].color, 
                                color2: FRUITS[nextLevel].color
                            });
                            bodiesToRemoveSet.add(bodyA.id);
                            bodiesToRemoveSet.add(bodyB.id);
                        }
                    }
                });
                
                // 2. ACT on collisions
                Events.on(engine, 'afterUpdate', () => {
                    if (bodiesToRemoveSet.size > 0) {
                        const bodiesToRemove = Composite.allBodies(world).filter(body => bodiesToRemoveSet.has(body.id));
                        bodiesToRemove.forEach(body => {
                            World.remove(world, body);
                        });
                        
                        let didMerge = false; 
                        bodiesToAddArray.forEach(data => {
                            const newFruit = createFruitBody(data.x, data.y, data.level, {
                                velocity: { x: Common.random(-1, 1), y: -2 } 
                            });
                            World.add(world, newFruit);
                            updateScore(score + data.score); 
                            createConfetti(data.x, data.y, data.color1, data.color2); 
                            didMerge = true;
                        });
                        
                        if (didMerge) {
                            // Play merge sound effect
                            playMergeSound();
                            if (navigator.vibrate) {
                                navigator.vibrate(50); 
                            }
                        }

                        bodiesToRemoveSet.clear();
                        bodiesToAddArray = [];
                    }

                    if (!isGameOver) {
                        saveCounter++;
                        if (saveCounter >= 60) { // Save roughly every second
                            saveGameState();
                            saveCounter = 0;
                        }
                    }
                });

                // --- Game Over Check ---
                Events.on(engine, 'collisionStay', (event) => {
                    if (isGameOver || isDropping || collisionTimeout) return; 
                    const pairs = event.pairs;
                    for (let i = 0; i < pairs.length; i++) {
                        const pair = pairs[i];
                        const bodyA = pair.bodyA;
                        const bodyB = pair.bodyB;
                        let fruitBody = null;

                        if (bodyA.label === 'gameOverLine' && bodyB.label === 'fruit') fruitBody = bodyB;
                        if (bodyB.label === 'gameOverLine' && bodyA.label === 'fruit') fruitBody = bodyA;

                        if (fruitBody) {
                            if (fruitBody.velocity.y < 0.05 && fruitBody.velocity.y > -0.05 && Math.abs(fruitBody.velocity.x) < 0.1) {
                                triggerGameOver();
                                break;
                            }
                        }
                    }
                });
                
                // --- UI Event Listeners ---
                gameWrapper.addEventListener('pointerdown', handlePointerDown, { passive: false });
                gameWrapper.addEventListener('pointermove', handlePointerMove, { passive: false });
                gameWrapper.addEventListener('pointerup', handlePointerUp, { passive: false });
                restartButton.addEventListener('click', handleRestart);
                newGameButton.addEventListener('click', showRestartConfirmation);
                restartConfirmYes.addEventListener('click', confirmRestart);
                restartConfirmNo.addEventListener('click', cancelRestart);
            }
            
            // --- Helper to check if any modal is visible ---
            function isModalVisible() {
                return !startModal.classList.contains('hidden') || 
                       !gameOverModal.classList.contains('hidden') || 
                       !restartConfirmModal.classList.contains('hidden');
            }
            
            // --- Event Handlers (to allow removal) ---
            function handlePointerDown(e) { 
                if (isModalVisible()) return;
                e.preventDefault(); 
                moveFruit(e.clientX); 
            }
            function handlePointerMove(e) { 
                if (isModalVisible()) return;
                e.preventDefault(); 
                moveFruit(e.clientX); 
            }
            function handlePointerUp(e) { 
                if (isModalVisible()) return;
                e.preventDefault(); 
                dropFruit(); 
            }
            
            function showRestartConfirmation() {
                if (!isGameOver) {
                    restartConfirmModal.classList.remove('hidden');
                }
            }
            
            function confirmRestart() {
                restartConfirmModal.classList.add('hidden');
                handleRestart();
            }
            
            function cancelRestart() {
                restartConfirmModal.classList.add('hidden');
            }
            
            function handleRestart() {
                localStorage.removeItem(GAME_STATE_KEY);
                
                // Stop background music before restart
                stopBackgroundMusic();
                
                Runner.stop(runner);
                Render.stop(render);
                gameWrapper.removeEventListener('pointerdown', handlePointerDown);
                gameWrapper.removeEventListener('pointermove', handlePointerMove);
                gameWrapper.removeEventListener('pointerup', handlePointerUp);
                restartButton.removeEventListener('click', handleRestart);
                newGameButton.removeEventListener('click', showRestartConfirmation);
                restartConfirmYes.removeEventListener('click', confirmRestart);
                restartConfirmNo.removeEventListener('click', cancelRestart); 
                Events.off(engine);
                Events.off(render);
                World.clear(world, false);
                Composite.clear(world, false, true);
                Engine.clear(engine);
                if (render.canvas) {
                    render.canvas.remove();
                }
                initGame(); 
            }

            
            // --- Utility Functions ---
            function updateScore(newScore) {
                score = newScore;
                scoreEl.textContent = score;

                if (score > highScore) {
                    highScore = score;
                    highScoreEl.textContent = highScore;
                }
            }
            
            function triggerGameOver() {
                if (isGameOver) return; 
                isGameOver = true;
                Runner.stop(runner);
                finalScoreEl.textContent = score;

                // Fade out background music
                stopBackgroundMusic();

                localStorage.setItem(HIGHSCORE_KEY, highScore.toString());
                localStorage.removeItem(GAME_STATE_KEY);

                gameOverModal.classList.remove('hidden');
            }

            // --- Handle Window Resize ---
            function setupResizeObserver() {
                const resizeObserver = new ResizeObserver(entries => {
                    for (let entry of entries) {
                        if (entry.target === gameWrapper) {
                            
                            const newWidth = entry.contentRect.width;
                            const newHeight = entry.contentRect.height; // Wrapper height
                            
                            // Check for 0 or invalid dimensions, or no change
                            if (!newWidth || !newHeight || newWidth === boxWidth) {
                                continue;
                            }
                            
                            if (!isGameOver && world && Composite.allBodies(world).length > 0) {
                                saveGameState();
                            }
                            
                            // Stop background music before reinitializing
                            stopBackgroundMusic();
                            
                            Runner.stop(runner);
                            Render.stop(render);
                            gameWrapper.removeEventListener('pointerdown', handlePointerDown);
                            gameWrapper.removeEventListener('pointermove', handlePointerMove);
                            gameWrapper.removeEventListener('pointerup', handlePointerUp);
                            restartButton.removeEventListener('click', handleRestart);
                            newGameButton.removeEventListener('click', showRestartConfirmation);
                            restartConfirmYes.removeEventListener('click', confirmRestart);
                            restartConfirmNo.removeEventListener('click', cancelRestart); 
                            Events.off(engine);
                            Events.off(render);
                            World.clear(world, false);
                            Composite.clear(world, false, true);
                            Engine.clear(engine);
                            if (render.canvas) {
                                render.canvas.remove();
                            }
                            
                            initGame();
                        }
                    }
                });
                
                resizeObserver.observe(gameWrapper);
            }
            
            // --- Handle Page Visibility/Focus Changes ---
            function setupVisibilityHandlers() {
                // Handle page visibility changes (tab switching)
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden) {
                        // Page lost focus/visibility
                        if (bgmController && bgmController.isPlaying()) {
                            bgmController.pause();
                            isMusicPaused = true;
                            if (startResumeButton && !startModal.classList.contains('hidden')) {
                                startResumeButton.textContent = 'Resume';
                            }
                        }
                    } else {
                        // Page gained focus/visibility
                        resumeBackgroundMusic();
                        if (bgmController && bgmController.isPlaying() && startResumeButton && !startModal.classList.contains('hidden')) {
                            startResumeButton.textContent = 'Pause';
                        }
                    }
                });
                
                // Handle window focus/blur events (app switching)
                window.addEventListener('blur', () => {
                    if (bgmController && bgmController.isPlaying()) {
                        bgmController.pause();
                        isMusicPaused = true;
                        if (startResumeButton && !startModal.classList.contains('hidden')) {
                            startResumeButton.textContent = 'Resume';
                        }
                    }
                });
                
                window.addEventListener('focus', () => {
                    resumeBackgroundMusic();
                    if (bgmController && bgmController.isPlaying() && startResumeButton && !startModal.classList.contains('hidden')) {
                        startResumeButton.textContent = 'Pause';
                    }
                });
            }
            
            // --- Setup Start/Resume Modal ---
            function setupStartModal() {
                // Set initial button text based on saved game
                if (localStorage.getItem(GAME_STATE_KEY)) {
                    startResumeButton.textContent = 'Resume';
                } else {
                    startResumeButton.textContent = 'Start';
                }
                
                // Modal is visible by default, add click handler
                startResumeButton.addEventListener('click', () => {
                    if (!bgmController) {
                        // First click - initialize and start music
                        initBackgroundMusic();
                        startBackgroundMusic();
                        startModal.classList.add('hidden');
                        isMusicPaused = false;
                    } else if (!bgmController.isPlaying()) {
                        // Music is paused - resume it
                        resumeBackgroundMusic();
                        startResumeButton.textContent = 'Pause';
                    } else {
                        // Music is playing - pause it
                        stopBackgroundMusic();
                        startResumeButton.textContent = 'Resume';
                    }
                });
            }
        
        }; // End of window.onload
    </script>
</body>
</html>
